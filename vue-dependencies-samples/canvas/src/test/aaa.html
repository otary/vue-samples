<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        #cv {
            border: 1px solid;
        }
    </style>
</head>
<body>

<canvas id="cv" width="640" height="1020"></canvas>

<button onclick="test()">旋转</button>
</body>
<script type="text/javascript">
    var ctx = cv.getContext("2d");
    var img = new Image();
    img.src = "./aaa.jpg";
    img.style.borderRadius = "50px"
    img.onload = function () {

        ctx.drawImage(img, 0, 0);

        /*ctx.save();

        ctx.arc(img.width/2, img.height/2, Math.min(img.width, img.height) / 2, 0, 2 * Math.PI);
        ctx.clip();
        ctx.drawImage(img, 0, 0);
        ctx.restore();*/


      /*  ctx.beginPath();

        ctx.arc(width- radius, height-radius, radius, 0, Math.PI/2);

        ctx.lineTo(radius, height);

        ctx.arc(radius, height-radius, radius, Math.PI/2, Math.PI);

        ctx.lineTo(0, radius);

        ctx.arc(radius, radius, radius, Math.PI, Math.PI*3/2);

        ctx.lineTo(width-radius, 0);

        ctx.arc(width-radius,radius,radius,Math.PI*3/2, Math.PI*2);

        ctx.closePath();*/

    }


    function test() {
        const angle = 180;
        const width = cv.width;
        const height = cv.height;

       // cv.width = height;
      //  cv.height = width;

        cv.width = width;
        cv.height = height;

       // ctx.translate(width, height)
       // ctx.rotate(angle * Math.PI / 180);
        ctx.drawImage(img, 0, 0);
    }

    /*ctx.beginPath();
    ctx.moveTo(0,0);
    document.onmousemove =  function (e) {
        ctx.drawImage(img,0,0);
        var e = e|| window.event;
        var x = e.clientX - cv.offsetLeft;
        var y = e.clientY-cv.offsetTop;
        console.log(x,y);
        //将图片剪裁,其中的参数分贝是哪个图片,从xy什么位置开始剪裁,剪裁宽高,剪裁之后要显示的xy位置,以及显示图片的宽高,这个方法剪裁的是原图
        ctx.drawImage(img,x-40,y-40,80,80,x-80,y-80,160,160);
        //图形组合,后面写的为源图片,此属性上面为目标图片,这个属性是显示在源图片内部的目标图片,并且源图片透明
        ctx.globalCompositeOperation="destination-in";
        ctx.arc(x,y,80,0,Math.PI*2,false);
        ctx.fill();
        //添加了源图片之后让目标图片还是完全显示:这行代码可以将目标图片放在最上面
        ctx.globalCompositeOperation="destination-over";
        ctx.drawImage(img,0,0);
    }*/

    const magnifyingGlassRadius = 80;
    const magnification = 2;

   // var x = 275, y = 246;

    /*cv.onmousemove = function(e) {
        cv.width = cv.width;

        var e = e|| window.event;
        var x = e.clientX - cv.offsetLeft;
        var y = e.clientY-cv.offsetTop;

        console.log(x,y);
        // 放大镜图片
        ctx.drawImage(img, x - (magnifyingGlassRadius / 2), y - (magnifyingGlassRadius / 2), magnifyingGlassRadius, magnifyingGlassRadius, x - magnifyingGlassRadius, y - magnifyingGlassRadius, magnifyingGlassRadius * magnification, magnifyingGlassRadius * magnification);
        //图形组合,上面为目标图片,下面为源图片,这个属性是显示在源图片内部的目标图片,并且源图片透明
        ctx.globalCompositeOperation = "destination-in";
        ctx.arc(x, y, magnifyingGlassRadius, 0, Math.PI * 2, false);
        ctx.fill();
        //添加了源图片之后让目标图片还是完全显示:这行代码可以将目标图片放在最上面
        ctx.globalCompositeOperation = "destination-over";
        ctx.drawImage(img, 0, 0);

    }*/

    /*cv.onmousedown=function(e){
        var e = e|| window.event;
        var x = e.clientX - cv.offsetLeft;
        var y = e.clientY-cv.offsetTop;
        ctx.beginPath();
        ctx.moveTo(x,y);
        document.onmousemove=function(e){
            //canvas中任何绘制的图形移动,都是一直在重新绘制,所以每次绘制之前需要清空画布,避免画布上多次重复绘制
            cv.width=cv.width;
            ctx.drawImage(img,0,0);
            var e = e|| window.event;
            var x = e.clientX - cv.offsetLeft;
            var y = e.clientY-cv.offsetTop;
            console.log(x,y);
            //将图片剪裁,其中的参数分贝是哪个图片,从xy什么位置开始剪裁,剪裁宽高,剪裁之后要显示的xy位置,以及显示图片的宽高,这个方法剪裁的是原图
            ctx.drawImage(img,x-40,y-40,80,80,x-80,y-80,160,160);
            //图形组合,后面写的为源图片,此属性上面为目标图片,这个属性是显示在源图片内部的目标图片,并且源图片透明
            ctx.globalCompositeOperation="destination-in";
            ctx.arc(x,y,80,0,Math.PI*2,false);
            ctx.fill();
            //添加了源图片之后让目标图片还是完全显示:这行代码可以将目标图片放在最上面
            ctx.globalCompositeOperation="destination-over";
            ctx.drawImage(img,0,0);
        }
    }
    //当鼠标抬起的时候,关闭鼠标移动事件
    cv.onmouseup = function(){
        document.onmousemove=null;
        //此刻虽然停止了,但是放大镜还停止在页面上,
        //让源图片完全显示使用这行代码:将源图片可以提高到所有图片的最上面
        ctx.globalCompositeOperation="source-over";
        //将Img作为源图片进行绘制
        ctx.drawImage(img,0,0);
    }

*/

</script>
</html>
