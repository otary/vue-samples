(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{466:function(e,t,v){"use strict";v.r(t);var r=v(56),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"_5-3-rtcrtpreceiver-接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-rtcrtpreceiver-接口"}},[e._v("#")]),e._v(" "),v("a",{attrs:{href:"http://w3c.github.io/webrtc-pc/#rtcrtpreceiver-interface",target:"_blank",rel:"noopener noreferrer"}},[e._v("5.3 RTCRtpReceiver 接口"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("code",[e._v("RTCRtpReceiver")]),e._v("接口允许应用程序检查"),v("code",[e._v("MediaStreamTrack")]),e._v("的接收。")]),e._v(" "),v("p",[e._v("要使用字符串"),v("code",[e._v("kind")]),e._v("来创建"),v("code",[e._v("RTCRtpReceiver")]),e._v("，请运行以下步骤：")]),e._v(" "),v("p",[e._v("1. 让接收器成为新的"),v("code",[e._v("RTCRtpReceiver")]),e._v("对象。\n2. 让"),v("code",[e._v("track")]),e._v("成为一个新的MediaStreamTrack对象[GETUSERMEDIA]。轨道源是接收器提供的远程源。请注意，"),v("code",[e._v("track.id")]),e._v("由用户代理生成，不会映射到远程端的任何轨道ID。\n3. 将"),v("code",[e._v("track.kind")]),e._v("初始化为"),v("code",[e._v("kind")]),e._v("。\n4. 将"),v("code",[e._v("track.label")]),e._v("初始化为将字符串“remote”与"),v("code",[e._v("kind")]),e._v("连接的结果。\n5. 将"),v("code",[e._v("track.readyState")]),e._v("初始化为"),v("code",[e._v("live")]),e._v("。\n6. 将"),v("code",[e._v("track.muted")]),e._v("初始化为"),v("code",[e._v("true")]),e._v("。请参阅"),v("code",[e._v("MediaStreamTrack")]),e._v("部分，了解在"),v("code",[e._v("MediaStreamTrack")]),e._v("接收媒体数据或者没有接收的情况下，静音属性如何反映。\n7. 让接收器将[[ReceiverTrack]]内部插槽初始化为"),v("code",[e._v("track")]),e._v("。\n8. 让接收器将[[ReceiverTransport]]内部插槽初始化为"),v("code",[e._v("null")]),e._v("。\n9. 让接收器将[[ReceiverRtcpTransport]]内部插槽初始化为"),v("code",[e._v("null")]),e._v("。\n10. 让接收器具有[[AssociatedRemoteMediaStreams]]内部槽，表示与该接收器的"),v("code",[e._v("MediaStreamTrack")]),e._v("对象相关联的"),v("code",[e._v("MediaStream")]),e._v("对象的列表，并初始化为空列表。\n11. 让接收器有一个[[ReceiveCodecs]]内部插槽，表示"),v("code",[e._v("RTCRtpCodecParameters")]),e._v("字典列表，并初始化为空列表。\n12. 返回接收器。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("[Exposed=Window] interface RTCRtpReceiver {\n    readonly        attribute MediaStreamTrack  track;\n    readonly        attribute RTCDtlsTransport? transport;\n    readonly        attribute RTCDtlsTransport? rtcpTransport;\n    static RTCRtpCapabilities?         getCapabilities (DOMString kind);\n    RTCRtpReceiveParameters            getParameters ();\n    sequence<RTCRtpContributingSource>    getContributingSources ();\n    sequence<RTCRtpSynchronizationSource> getSynchronizationSources ();\n    Promise<RTCStatsReport>   getStats();\n};\n")])])]),v("p",[v("strong",[e._v("属性")]),e._v(" "),v("em",[e._v("track")]),e._v(" 类型"),v("code",[e._v("MediaStreamTrack")]),e._v("，只读\n"),v("code",[e._v("track")]),e._v("属性是与此"),v("code",[e._v("RTCRtpReceiver")]),e._v("对象接收器关联的轨道。")]),e._v(" "),v("p",[e._v("请注意，"),v("code",[e._v("track.stop（）")]),e._v("是最终的，尽管克隆不受影响。由于"),v("code",[e._v("receiver.track.stop（）")]),e._v("不会隐式停止接收器，因此继续发送"),v("code",[e._v("Receiver Reports")]),e._v("。获取时，属性必须返回[[ReceiverTrack]]槽的值。")]),e._v(" "),v("p",[v("em",[e._v("transport")]),e._v(" "),v("code",[e._v("RTCDtlsTransport")]),e._v("类型的传输，只读，可空")]),e._v(" "),v("p",[e._v("传输属性是以RTP分组的形式接收接收者的轨道的媒体的传输。在构造"),v("code",[e._v("RTCDtlsTransport")]),e._v("对象之前，transport属性将为null。使用捆绑时，多个"),v("code",[e._v("RTCRtpReceiver")]),e._v("对象将共享一个传输，并将通过同一传输接收 RTP 和 RTCP。")]),e._v(" "),v("p",[e._v("获取时，属性必须返回[[ReceiverTransport]]槽的值。")]),e._v(" "),v("p",[v("code",[e._v("rtcpTransport")]),e._v("类型为"),v("code",[e._v("RTCDtlsTransport")]),e._v("，只读，可空")]),e._v(" "),v("p",[v("code",[e._v("rtcpTransport")]),e._v("属性是发送和接收 RTCP 的传输。在构造"),v("code",[e._v("RTCDtlsTransport")]),e._v("对象之前，"),v("code",[e._v("rtcpTransport")]),e._v("属性将为"),v("code",[e._v("null")]),e._v("。当使用 RTCP mux（或捆绑，强制执行 RTCP mux）时，"),v("code",[e._v("rtcpTransport")]),e._v("将为"),v("code",[e._v("null")]),e._v("，并且 RTP 和 RTCP 流量都将通过传输流动。")]),e._v(" "),v("p",[e._v("获取时，属性必须返回[[ReceiverRtcpTransport]]槽的值。")]),e._v(" "),v("p",[v("strong",[e._v("方法")]),e._v(" "),v("code",[e._v("getCapabilities")]),e._v("，静态\n"),v("code",[e._v("getCapabilities（）")]),e._v("方法返回系统功能的最乐观视图，用于接收给定类型的媒体。它不保留任何资源，端口或其他状态，但旨在提供一种方法来发现浏览器的功能类型，包括可能支持的编解码器。用户代理必须支持“音频”和“视频”的类型值。如果系统没有与"),v("code",[e._v("kind")]),e._v("参数的值相对应的功能，则"),v("code",[e._v("getCapabilities")]),e._v("返回"),v("code",[e._v("null")]),e._v("。")]),e._v(" "),v("p",[e._v("这些功能通常在设备上提供持久的跨源信息，从而增加了应用程序的指纹表面。在隐私敏感的上下文中，浏览器可以考虑缓解，例如仅报告功能的公共子集。")]),e._v(" "),v("p",[v("code",[e._v("getParameters")]),e._v(" "),v("code",[e._v("getParameters（）")]),e._v("方法返回"),v("code",[e._v("RTCRtpReceiver")]),e._v("对象的当前参数，用于解码轨道的方式。\n调用"),v("code",[e._v("getParameters")]),e._v("时，"),v("code",[e._v("RTCRtpReceiveParameters")]),e._v("字典构造如下：\n根据当前远程描述中存在的 RID 填充编码。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("headerExtensions")]),e._v("序列基于接收器当前准备接收的头扩展来填充。")]),e._v(" "),v("li",[e._v("编解码器序列基于接收器当前准备接收的编解码器来填充。\n注意本地和远程描述可能会影响此编解码器列表。例如，如果提供了三个编解码器，接收器将准备好接收它们中的每一个，并将从"),v("code",[e._v("getParameters")]),e._v("返回它们。但是如果远程端点只回答两个，则"),v("code",[e._v("getParameters")]),e._v("将不再返回缺少的编解码器，因为接收器不再需要准备接收它。")]),e._v(" "),v("li",[e._v("如果接收器当前准备接收缩小的RTCP数据包，则"),v("code",[e._v("rtcp.reducedSize")]),e._v("设置为true，否则设置为"),v("code",[e._v("false")]),e._v("。 "),v("code",[e._v("rtcp.cname")]),e._v("被省略了。")])]),e._v(" "),v("p",[v("code",[e._v("getContributingSources")]),e._v("\n返回此RTCRtpReceiver在过去10秒内收到的每个唯一CSRC标识符的RTCRtpContributingSource。")]),e._v(" "),v("p",[v("code",[e._v("getSynchronizationSources")]),e._v("\n返回此"),v("code",[e._v("RTCRtpReceiver")]),e._v("在过去10秒内收到的每个唯一 SSRC 标识符的"),v("code",[e._v("RTCRtpContributingSource")])]),e._v(" "),v("p",[v("code",[e._v("getStats")]),e._v("\n仅收集此接收器的统计信息并异步报告结果。\n当调用"),v("code",[e._v("getStats（）")]),e._v("方法时，用户代理必须运行以下步骤：")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("让"),v("code",[e._v("selector")]),e._v("成为调用该方法的"),v("code",[e._v("RTCRtpReceiver")]),e._v("对象。")])]),e._v(" "),v("li",[v("p",[e._v("让"),v("code",[e._v("p")]),e._v("成为新的承诺，并行执行以下步骤：")]),e._v(" "),v("ol",[v("li",[e._v("根据统计选择算法收集选择器指示的统计数据。")]),e._v(" "),v("li",[e._v("使用生成的RTCStatsReport对象解析p，其中包含收集的统计信息。")])])]),e._v(" "),v("li",[v("p",[e._v("返回p。")])])]),e._v(" "),v("p",[v("code",[e._v("RTCRtpContributingSource")]),e._v("和"),v("code",[e._v("RTCRtpSynchronizationSource")]),e._v("字典分别包含有关给定贡献源（CSRC）或同步源（SSRC）的信息，包括源所贡献的数据包的最近时间。浏览器必须保留前 10 秒内收到的 RTP 数据包的信息。当包含在 RTP 数据包中的第一个音频或视频帧被传送到"),v("code",[e._v("RTCRtpReceiver")]),e._v("的"),v("code",[e._v("MediaStreamTrack")]),e._v("进行播出时，用户代理必须排队任务，以根据数据包的内容更新"),v("code",[e._v("RTCRtpContributingSource")]),e._v("和"),v("code",[e._v("RTCRtpSynchronizationSource")]),e._v("字典的相关信息。每次更新与 SSRC 标识符对应的"),v("code",[e._v("RTCRtpSynchronizationSource")]),e._v("字典相关的信息，并且如果 RTP 分组包含 CSRC 标识符，则还更新与那些 CSRC 标识符对应的"),v("code",[e._v("RTCRtpContributingSource")]),e._v("字典相关的信息。")]),e._v(" "),v("p",[e._v("NOTE\n如一致性部分所述，只要最终结果是等效的，可以以任何方式实现作为算法的要求。因此，实现不需要为每个数据包逐字排队任务，只要最终结果是在单个事件循环任务执行中，所有返回的特定"),v("code",[e._v("RTCRtpReceiver")]),e._v("的"),v("code",[e._v("RTCRtpSynchronizationSource")]),e._v("和"),v("code",[e._v("RTCRtpContributingSource")]),e._v("字典都包含来自 RTP 流中单个点的信息。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("dictionary RTCRtpContributingSource {\n    required DOMHighResTimeStamp timestamp;\n    required unsigned long       source;\n             double              audioLevel;\n};\n")])])]),v("h4",{attrs:{id:"字典-rtcrtpcontributingsource-成员"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#字典-rtcrtpcontributingsource-成员"}},[e._v("#")]),e._v(" 字典 RTCRtpContributingSource 成员")]),e._v(" "),v("p",[v("em",[e._v("timestamp")]),e._v(" 类型为DOMHighResTimeStamp， 必需\nDOMHighResTimeStamp [HIGHRES-TIME]类型的时间戳，指示到达源自此源的RTP数据包的媒体播放的最近时间。时间戳在播出时定义为"),v("code",[e._v("performance.timeOrigin + performance.now（）")]),e._v("。")]),e._v(" "),v("p",[v("em",[e._v("source")]),e._v(" 类型为unsigned，必需\n贡献或同步源的 CSRC 或 SSRC 标识符。")]),e._v(" "),v("p",[v("em",[e._v("audioLevel")]),e._v(" 类型为double\n仅适用于音频接收器。这是 0..1（线性）之间的值，其中 1.0 表示 0 dBov，0 表示静音，0.5 表示声压级从 0 dBov变化约 6 dBSPL。\n对于 CSRC，如果存在 RFC 6465 标头扩展，则必须从[RFC6465]中定义的级别值转换，否则该成员必须不存在。\n对于 SSRC，如果存在 RFC 6464 标头扩展，则必须从[RFC6464]中定义的级别值转换，否则用户代理必须从音频数据计算值（音频接收器不得缺少该成员）。\n两个 RFC 将级别定义为 0 到 127 的整数值，表示相对于系统可能编码的最大信号的负分贝的音频电平。因此，0 代表系统可能编码的最响亮信号，127 代表静音。\n要将这些值转换为线性 0..1 范围，将值 127 转换为 0，并使用以下公式转换所有其他值："),v("code",[e._v("10 ^（ - rfc_level / 20）")]),e._v("。")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("dictionary RTCRtpSynchronizationSource : RTCRtpContributingSource {\n    boolean voiceActivityFlag;\n};\n")])])]),v("p",[v("strong",[e._v("字典 RTCRtpSynchronizationSource 成员")])]),e._v(" "),v("p",[v("em",[e._v("voiceActivityFlag")]),e._v(" boolean类型\n仅适用于音频接收器。从该源播放的最后一个RTP数据包是否包含语音活动（true）或不包含语音活动（false）。如果 RFC 6464 扩展头不存在，或者对等体通过将“vad”扩展属性设置为“off”来表示它没有使用 V bit，如[RFC6464]第 4 节中所述，则"),v("code",[e._v("voiceActivityFlag")]),e._v("将是缺席。")])])}),[],!1,null,null,null);t.default=_.exports}}]);