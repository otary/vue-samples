(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{408:function(e,a,t){"use strict";t.r(a);var n=t(56),v=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_6-2-rtcdatachannel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-rtcdatachannel"}},[e._v("#")]),e._v(" 6.2 "),t("code",[e._v("RTCDataChannel")])]),e._v(" "),t("p",[t("code",[e._v("RTCDataChannel")]),e._v("接口表示两个对等体之间的双向数据信道。 "),t("code",[e._v("RTCDataChannel")]),e._v("是通过"),t("code",[e._v("RTCPeerConnection")]),e._v("对象上的工厂方法创建的。浏览器之间发送的消息在[RTCWEB-DATA]和[RTCWEB-DATA-PROTOCOL]中描述。")]),e._v(" "),t("p",[e._v("有两种方法可以与"),t("code",[e._v("RTCDataChannel")]),e._v("建立连接。第一种方法是在其中一个对等体上创建一个"),t("code",[e._v("RTCDataChannel")]),e._v("，并且协商的"),t("code",[e._v("RTCDataChannelInit")]),e._v("字典成员为未设置或被设置为默认值false。这将在带内公布新通道，并在另一个对等体上触发带有相应"),t("code",[e._v("RTCDataChannel")]),e._v("对象的"),t("code",[e._v("RTCDataChannelEvent")]),e._v("。第二种方法是让应用程序协商"),t("code",[e._v("RTCDataChannel")]),e._v("。为此，创建一个"),t("code",[e._v("RTCDataChannel")]),e._v("对象，将协商的"),t("code",[e._v("RTCDataChannelInit")]),e._v("字典成员设置为true，并通过带外信号（例如通过Web服务器）向另一方发出信号，它应该创建一个带有协商的"),t("code",[e._v("RTCDataChannelInit")]),e._v("字典成员集的相应"),t("code",[e._v("RTCDataChannel")]),e._v("，字典成员被设置为true，并且具有相同"),t("code",[e._v("id")]),e._v("。这将连接两个单独创建的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。第二种方法可以创建具有非对称属性的通道，并通过指定匹配的ID以声明方式创建通道。")]),e._v(" "),t("p",[e._v("每个"),t("code",[e._v("RTCDataChannel")]),e._v("都有一个关联的底层数据传输，用于将实际数据传输到另一个对等端。在SCTP数据信道利用"),t("code",[e._v("RTCSctpTransport")]),e._v("（表示SCTP关联的状态）的情况下，底层数据传输是SCTP流对。底层数据传输的传输属性（例如有序发送设置和可靠性模式）由对等方在创建通道时配置。创建通道后，通道的属性不会更改。对等体之间的实际有线协议由WebRTC DataChannel协议规范[RTCWEB-DATA]指定。")]),e._v(" "),t("p",[e._v("可以将"),t("code",[e._v("RTCDataChannel")]),e._v("配置为在不同的依赖模式下操作。可靠的信道确保通过重新传输在另一个对等体上传达数据。不可靠信道被配置为限制重传次数（"),t("code",[e._v("maxRetransmits")]),e._v("）或设置允许传输（包括重传）的时间（"),t("code",[e._v("maxPacketLifeTime")]),e._v("）。这些属性不能同时使用，这样做会导致错误。不设置任何这些属性会得到可靠的通道。")]),e._v(" "),t("p",[e._v("使用"),t("code",[e._v("createDataChannel")]),e._v("创建或通过"),t("code",[e._v("RTCDataChannelEvent")]),e._v("调度的"),t("code",[e._v("RTCDataChannel")]),e._v("必须最初处于"),t("code",[e._v("connecing")]),e._v("状态。当"),t("code",[e._v("RTCDataChannel")]),e._v("对象的底层数据传输准备就绪时，用户代理必须宣布"),t("code",[e._v("RTCDataChannel")]),e._v("为open。")]),e._v(" "),t("p",[e._v("要创建"),t("code",[e._v("RTCDataChannel")]),e._v("，请运行以下步骤:")]),e._v(" "),t("ol",[t("li",[e._v("让channel成为新创建的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。")]),e._v(" "),t("li",[e._v("让通道将[[ReadyState]]内部插槽初始化为"),t("code",[e._v("“connecting”")]),e._v("。"),t("a",{attrs:{href:"https://github.com/web-platform-tests/wpt/blob/master/webrtc/RTCPeerConnection-ondatachannel.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("测试1"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("让通道将[[BufferedAmount]]内部插槽初始化为"),t("code",[e._v("0")]),e._v("。")]),e._v(" "),t("li",[e._v("让通道具有内部插槽，名为[[DataChannelLabel]]，[[Ordered]]，[[MaxPacketLifeTime]]，[[MaxRetransmits]]，[[DataChannelProtocol]]，[[Negotiated]]，[[DataChannelId]]和[ [DataChannelPriority]。")]),e._v(" "),t("li",[e._v("返回通道。")])]),e._v(" "),t("p",[e._v("当用户代理宣布"),t("code",[e._v("RTCDataChannel")]),e._v("为open时，用户代理必须对任务进行排队,运行以下步骤：")]),e._v(" "),t("ol",[t("li",[e._v("如果关联的"),t("code",[e._v("RTCPeerConnection")]),e._v("对象的[[IsClosed]]插槽为true，则中止这些步骤。")]),e._v(" "),t("li",[e._v("让channel成为要宣布的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。")]),e._v(" "),t("li",[e._v("如果通道的[[ReadyState]]为"),t("code",[e._v("closing")]),e._v("或"),t("code",[e._v("closed")]),e._v("，请中止这些步骤。")]),e._v(" "),t("li",[e._v("将通道的[[ReadyState]]插槽设置为"),t("code",[e._v("open")]),e._v("。")]),e._v(" "),t("li",[e._v("在通道上触发一个名为open的事件。"),t("a",{attrs:{href:"https://github.com/web-platform-tests/wpt/blob/master/webrtc/RTCPeerConnection-ondatachannel.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("测试1"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("当要宣布底层数据传输时（另一个对等方创建一个negotiated为未设置或设置为false的通道），未启动创建过程的对等方的用户代理必须对任务排序，以运行以下步骤：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("如果关联的"),t("code",[e._v("RTCPeerConnection")]),e._v("对象的[[IsClosed]]插槽为true，则中止这些步骤。")])]),e._v(" "),t("li",[t("p",[e._v("创建一个"),t("code",[e._v("RTCDataChannel")]),e._v("，通道。")])]),e._v(" "),t("li",[t("p",[e._v("让配置成为从另一个对等体接收的信息包，作为建立由WebRTC数据通道协议规范[RTCWEB-DATA-PROTOCOL]描述的底层数据传输的过程的一部分。")])]),e._v(" "),t("li",[t("p",[e._v("将通道的[[DataChannelLabel]]，[[Ordered]]，[[MaxPacketLifeTime]]，[[MaxRetransmits]]，[[DataChannelProtocol]]和[[DataChannelId]]内部插槽初始化为配置中的相应值。")])]),e._v(" "),t("li",[t("p",[e._v("将通道的[[Negotiated]]内部插槽初始化为"),t("code",[e._v("false")]),e._v("。")])]),e._v(" "),t("li",[t("p",[e._v("根据配置中的整数优先级值初始化通道的[[DataChannelPriority]]内部插槽，根据以下映射：")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",[e._v("configuration priority value")]),e._v(" "),t("th",[e._v("RTCPriorityType value")])])]),e._v(" "),t("tbody",[t("tr",[t("td",[e._v("0 to 128")]),e._v(" "),t("td",[e._v("very-low")])]),e._v(" "),t("tr",[t("td",[e._v("129 to 256")]),e._v(" "),t("td",[e._v("low")])]),e._v(" "),t("tr",[t("td",[e._v("257 to 512")]),e._v(" "),t("td",[e._v("medium")])]),e._v(" "),t("tr",[t("td",[e._v("513 and greater")]),e._v(" "),t("td",[e._v("high")])])])])]),e._v(" "),t("li",[t("p",[e._v("将通道的[[ReadyState]]设置为"),t("code",[e._v("open")]),e._v("（但不要触发"),t("code",[e._v("open")]),e._v("事件）。")]),e._v(" "),t("blockquote",[t("p",[e._v("NOTE:这允许在触发open事件之前开始在"),t("code",[e._v("datachannel")]),e._v("事件处理程序内发送消息。")])])]),e._v(" "),t("li",[t("p",[e._v("使用"),t("code",[e._v("RTCDataChannelEvent")]),e._v("接口触发名为"),t("code",[e._v("datachannel")]),e._v("的事件，并将channel属性设置为"),t("code",[e._v("RTCPeerConnection")]),e._v("对象的channel。")])]),e._v(" "),t("li",[t("p",[e._v("宣布数据通道处于open状态。")])])]),e._v(" "),t("p",[e._v("通过运行关闭过程，可以以非突然的方式拆除"),t("code",[e._v("RTCDataChannel")]),e._v("对象的底层数据传输。当发生这种情况时，用户代理必须排队任务以运行以下步骤：")]),e._v(" "),t("ol",[t("li",[e._v("让channel成为其传输已关闭的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。")]),e._v(" "),t("li",[e._v("除非通过通道的"),t("code",[e._v("close")]),e._v("方法启动该过程，否则将通道的[[ReadyState]]插槽设置为"),t("code",[e._v("closing")]),e._v("。")]),e._v(" "),t("li",[e._v("并行运行以下步骤:\n"),t("ol",[t("li",[e._v("完成发送channel的所有当前待处理消息。")]),e._v(" "),t("li",[e._v("遵循为通道的底层传输定义的关闭过程：\n"),t("ol",[t("li",[e._v("如果是基于SCTP的传输，请按照[RTCWEB-DATA]的6.7节进行操作。")])])]),e._v(" "),t("li",[e._v("按照相关步骤渲染通道的数据传输。")])])])]),e._v(" "),t("p",[e._v("当"),t("code",[e._v("RTCDataChannel")]),e._v("对象的基础数据传输已关闭时，用户代理必须对任务进行排队以运行以下步骤：")]),e._v(" "),t("ol",[t("li",[e._v("让channel成为其传输已关闭的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。")]),e._v(" "),t("li",[e._v("将通道的[[ReadyState]]插槽设置为"),t("code",[e._v("closed")]),e._v("。")]),e._v(" "),t("li",[e._v("如果传输因错误而关闭，则使用"),t("code",[e._v("RTCErrorEvent")]),e._v("接口触发名为"),t("code",[e._v("error")]),e._v("的事件，并在通道中将其"),t("code",[e._v("errorDetail")]),e._v("属性设置为"),t("code",[e._v("“sctp-failure”")]),e._v("。")]),e._v(" "),t("li",[e._v("在通道内发起一个名为"),t("code",[e._v("close")]),e._v("的事件。")])]),e._v(" "),t("p",[e._v("在某些情况下，用户代理可能无法创建"),t("code",[e._v("RTCDataChannel")]),e._v("的基础数据传输。例如，数据通道的"),t("code",[e._v("id")]),e._v("可能超出SCTP握手中[RTCWEB-DATA]实现协商的范围。当用户代理确定无法创建"),t("code",[e._v("RTCDataChannel")]),e._v("的基础数据传输时，用户代理必须排队任务以运行以下步骤：")]),e._v(" "),t("ol",[t("li",[e._v("令channel为"),t("code",[e._v("RTCDataChannel")]),e._v("对象，用户代理无法为其创建底层数据传输。")]),e._v(" "),t("li",[e._v("将通道的[[ReadyState]]插槽设置为"),t("code",[e._v("closed")]),e._v("。")]),e._v(" "),t("li",[e._v("使用"),t("code",[e._v("RTCErrorEvent")]),e._v("接口触发名为"),t("code",[e._v("error")]),e._v("的事件，并在通道中将"),t("code",[e._v("errorDetail")]),e._v("属性设置为“data-channel-failure”。")]),e._v(" "),t("li",[e._v("在通道上发起一个名为"),t("code",[e._v("close")]),e._v("的事件。")])]),e._v(" "),t("p",[e._v("当通过类型"),t("code",[e._v("type")]),e._v("和数据"),t("code",[e._v("rawData")]),e._v("的底层数据传输接收到"),t("code",[e._v("RTCDataChannel")]),e._v("消息时，用户代理必须排队任务以运行以下步骤：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("令channel为用户代理已收到消息的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。")])]),e._v(" "),t("li",[t("p",[e._v("如果通道的[[ReadyState]]插槽不为"),t("code",[e._v("open")]),e._v("，则中止这些步骤并丢弃"),t("code",[e._v("rawData")]),e._v("。")])]),e._v(" "),t("li",[t("p",[e._v("通过打开"),t("code",[e._v("type")]),e._v("和"),t("code",[e._v("channel")]),e._v("的"),t("code",[e._v("binaryType")]),e._v("来执行子步骤：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("如果type表示rawData是一个字符串:")]),e._v(" "),t("p",[e._v("令数据为DOMString，表示将"),t("code",[e._v("rawData")]),e._v("解码为UTF-8的结果。")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/web-platform-tests/wpt/blob/master/webrtc/datachannel-emptystring.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("测试1"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[e._v("如果type表示rawData是二进制而"),t("code",[e._v("binaryType")]),e._v("是"),t("code",[e._v("“blob”")]),e._v("：")]),e._v(" "),t("p",[e._v("让data成为包含rawData作为其原始数据源的新"),t("code",[e._v("Blob")]),e._v("对象。")])]),e._v(" "),t("li",[t("p",[e._v("如果type表示rawData是二进制，而"),t("code",[e._v("binaryType")]),e._v("是"),t("code",[e._v("“arraybuffer”")]),e._v("：")]),e._v(" "),t("p",[e._v("让data成为一个新的"),t("code",[e._v("ArrayBuffer")]),e._v("对象，包含rawData作为原始数据源。")])])])]),e._v(" "),t("li",[t("p",[e._v("使用MessageEvent接口触发名为"),t("code",[e._v("message")]),e._v("的事件，其"),t("code",[e._v("origin")]),e._v("属性初始化为创建通道关联的"),t("code",[e._v("RTCPeerConnection")]),e._v("的文档的原点，并且"),t("code",[e._v("data")]),e._v("属性初始化为通道上的数据。")])])]),e._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Exposed")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Window")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("interface")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCDataChannel")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EventTarget")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    readonly        attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("USVString")]),e._v("           label"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")]),e._v("             ordered"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute unsigned "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v("     maxPacketLifeTime"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute unsigned "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v("     maxRetransmits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("USVString")]),e._v("           protocol"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")]),e._v("             negotiated"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute unsigned "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v("     id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCPriorityType")]),e._v("     priority"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCDataChannelState")]),e._v(" readyState"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute unsigned "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v("       bufferedAmount"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n                    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EnforceRange")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n                    attribute unsigned "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("long")]),e._v("       bufferedAmountLowThreshold"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n                    attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EventHandler")]),e._v("        onopen"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n                    attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EventHandler")]),e._v("        onbufferedamountlow"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n                    attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EventHandler")]),e._v("        onerror"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n                    attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EventHandler")]),e._v("        onclose"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" close "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n                    attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EventHandler")]),e._v("        onmessage"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n                    attribute "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("DOMString")]),e._v("           binaryType"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" send "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("USVString")]),e._v(" data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" send "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Blob")]),e._v(" data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" send "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ArrayBuffer")]),e._v(" data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" send "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ArrayBufferView")]),e._v(" data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[t("strong",[e._v("属性")])]),e._v(" "),t("p",[e._v("USVString类型的"),t("code",[e._v("label")]),e._v("，只读:label属性表示可用于将此"),t("code",[e._v("RTCDataChannel")]),e._v("对象与其他"),t("code",[e._v("RTCDataChannel")]),e._v("对象区分开的标签。允许脚本使用相同的标签创建多个"),t("code",[e._v("RTCDataChannel")]),e._v("对象。获取时，属性必须返回[[DataChannelLabel]]槽的值。"),t("a",{attrs:{href:"https://github.com/web-platform-tests/wpt/blob/master/webrtc/RTCPeerConnection-createDataChannel.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("测试1"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("boolean类型"),t("code",[e._v("ordered")]),e._v("，只读：如果"),t("code",[e._v("RTCDataChannel")]),e._v("有序，则"),t("code",[e._v("ordered")]),e._v("属性返回true，如果允许无序传递，则返回false。获取时，属性必须返回[[Ordered]]槽的值。")]),e._v(" "),t("p",[e._v("unsigned short类型的"),t("code",[e._v("maxPacketLifeTime")]),e._v("，只读的，可以为null："),t("code",[e._v("maxPacketLifeTime")]),e._v("属性返回在不可靠模式下可能发生传输和重传的时间窗口的长度（以毫秒为单位）。获取时，属性必须返回[[MaxPacketLifeTime]]槽的值。")]),e._v(" "),t("p",[e._v("unsigned short类型的"),t("code",[e._v("maxRetransmits")]),e._v("，只读的，可以为null："),t("code",[e._v("maxRetransmits")]),e._v("属性返回在不可靠模式下尝试的最大重新传输次数。获取时，属性必须返回[[MaxRetransmits]]槽的值。")]),e._v(" "),t("p",[e._v("USVString类型的"),t("code",[e._v("protocol")]),e._v("，只读的："),t("code",[e._v("protocol")]),e._v("属性返回与此"),t("code",[e._v("RTCDataChannel")]),e._v("一起使用的子协议的名称。获取时，属性必须返回[[DataChannelProtocol]]槽的值。")]),e._v(" "),t("p",[e._v("boolean类型的"),t("code",[e._v("negotiated")]),e._v("，只读的：如果此"),t("code",[e._v("RTCDataChannel")]),e._v("由应用程序协商，则"),t("code",[e._v("negotiated")]),e._v("属性返回true，否则返回false。获取时，属性必须返回[[Negotiated]]插槽的值。")]),e._v(" "),t("p",[e._v("unsigned short类型的"),t("code",[e._v("id")]),e._v("，只读的，可以为null："),t("code",[e._v("id")]),e._v("属性返回此"),t("code",[e._v("RTCDataChannel")]),e._v("的ID。该值初始为null，如果在创建通道时未提供ID，则返回该值，并且尚未协商SCTP传输的DTLS角色。否则，它将返回由脚本选择的ID或由用户代理根据[RTCWEB-DATA-PROTOCOL]生成的ID。将ID设置为非空值后，它不会更改。获取时，属性必须返回[[DataChannelId]]槽的值。"),t("a",{attrs:{href:"https://github.com/web-platform-tests/wpt/blob/master/webrtc/RTCDataChannel-id.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("测试2"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("RTCPriorityType类型的"),t("code",[e._v("priority")]),e._v("，只读:"),t("code",[e._v("priority")]),e._v("属性返回此"),t("code",[e._v("RTCDataChannel")]),e._v("的优先级。优先级由用户代理在通道创建时分配。获取时，属性必须返回[[DataChannelPriority]]槽的值。")]),e._v(" "),t("p",[t("code",[e._v("RTCDataChannelState")]),e._v("类型的"),t("code",[e._v("readyState")]),e._v("，只读的："),t("code",[e._v("readyState")]),e._v("属性表示"),t("code",[e._v("RTCDataChannel")]),e._v("对象的状态。获取时，属性必须返回[[ReadyState]]槽的值。")]),e._v(" "),t("p",[e._v("unsigned long类型的"),t("code",[e._v("bufferedAmount")]),e._v("，只读的：获取时，"),t("code",[e._v("bufferedAmount")]),e._v("属性必须返回[[BufferedAmount]]槽的值。该属性公开使用"),t("code",[e._v("send（)")]),e._v("排队的应用程序数据（UTF-8文本和二进制数据）的字节数。即使数据传输可以并行发生，在当前任务返回事件循环以防止race condition之前，不得减小返回值。该值不包括协议产生的帧开销，或操作系统或网络硬件完成的缓冲。只要[[ReadyState]]插槽打开，[[BufferedAmount]]插槽的值只会随着每次调用send（）方法而增加;但是，一旦通道关闭，插槽不会重置为零。当底层数据传输从其队列发送数据时，用户代理必须排队一个任务，该任务随着发送的字节数减少[[BufferedAmount]]。")]),e._v(" "),t("p",[e._v("unsigned long类型的"),t("code",[e._v("bufferedAmountLowThreshold")]),e._v(":"),t("code",[e._v("bufferedAmountLowThreshold")]),e._v("属性设置"),t("code",[e._v("bufferedAmount")]),e._v("被视为低的阈值。当"),t("code",[e._v("bufferedAmount")]),e._v("从此阈值以上减小到等于或低于此阈值时，将触发"),t("code",[e._v("bufferedamountlow")]),e._v("事件。 "),t("code",[e._v("bufferedAmountLowThreshold")]),e._v("在每个新的"),t("code",[e._v("RTCDataChannel")]),e._v("上最初为零，但应用程序可能随时更改其值。")]),e._v(" "),t("p",[e._v("EventHandler类型的"),t("code",[e._v("onopen")]),e._v(":此事件处理程序的事件类型为"),t("code",[e._v("open")]),e._v("。")]),e._v(" "),t("p",[e._v("eventHandler类型的"),t("code",[e._v("onbufferedamountlow")]),e._v(":此事件处理程序的事件类型为"),t("code",[e._v("bufferedamountlow")]),e._v("。")]),e._v(" "),t("p",[e._v("eventHandler类型的"),t("code",[e._v("onerror")]),e._v(":此事件处理程序的事件类型是"),t("code",[e._v("RTCErrorEvent")]),e._v("。"),t("code",[e._v("errorDetail")]),e._v("包含“sctp-failure”，"),t("code",[e._v("sctpCauseCode")]),e._v("包含SCTP Cause Code值，并且"),t("code",[e._v("message")]),e._v("包含SCTP Cause-Specific-Information，可能包含其他文本。")]),e._v(" "),t("p",[e._v("EventHandler类型的"),t("code",[e._v("onclose")]),e._v(":此事件处理程序的事件类型为"),t("code",[e._v("close")]),e._v("。")]),e._v(" "),t("p",[e._v("eventHandler类型的"),t("code",[e._v("onmessage")]),e._v(":此事件处理程序的事件类型是"),t("code",[e._v("message")]),e._v("。")]),e._v(" "),t("p",[e._v("DOMString类型的"),t("code",[e._v("binaryType")]),e._v(":获取时，"),t("code",[e._v("binaryType")]),e._v("属性必须返回上次设置的值。在设置时，如果新值是字符串"),t("code",[e._v("“blob”")]),e._v("或字符串"),t("code",[e._v("“arraybuffer”")]),e._v("，则将IDL属性设置为此新值。否则，抛出一个"),t("code",[e._v("SyntaxError")]),e._v("。创建"),t("code",[e._v("RTCDataChannel")]),e._v("对象时，必须将"),t("code",[e._v("binaryType")]),e._v("属性初始化为字符串"),t("code",[e._v("“blob”")]),e._v("。")]),e._v(" "),t("p",[e._v("此属性控制二进制数据如何向脚本公开。有关更多信息，请参阅[WEBSOCKETS-API]。")]),e._v(" "),t("p",[t("strong",[e._v("方法")])]),e._v(" "),t("p",[t("code",[e._v("close")]),e._v(":")]),e._v(" "),t("p",[e._v("关闭"),t("code",[e._v("RTCDataChannel")]),e._v("。无论"),t("code",[e._v("RTCDataChannel")]),e._v("对象是由对等方还是远程对等方创建，都可以调用它。")]),e._v(" "),t("p",[e._v("调用close方法时，用户代理必须执行以下步骤：")]),e._v(" "),t("ol",[t("li",[e._v("让channel成为即将关闭的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。")]),e._v(" "),t("li",[e._v("如果通道的[[ReadyState]]插槽为"),t("code",[e._v("closing")]),e._v("或"),t("code",[e._v("closed")]),e._v("，则中止这些步骤。")]),e._v(" "),t("li",[e._v("将通道的[[ReadyState]]插槽设置为"),t("code",[e._v("closing")]),e._v("。")]),e._v(" "),t("li",[e._v("如果关闭程序尚未开始，请启动它。")])]),e._v(" "),t("p",[t("code",[e._v("send")])]),e._v(" "),t("p",[e._v("使用参数类型"),t("code",[e._v("string")]),e._v("对象运行"),t("code",[e._v("send（）")]),e._v("算法描述的步骤。"),t("a",{attrs:{href:"https://github.com/web-platform-tests/wpt/blob/master/webrtc/RTCDataChannel-send.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("测试1"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("code",[e._v("send")])]),e._v(" "),t("p",[e._v("使用参数类型"),t("code",[e._v("Blob")]),e._v("对象运行"),t("code",[e._v("send（）")]),e._v("算法描述的步骤。")]),e._v(" "),t("p",[t("code",[e._v("send")])]),e._v(" "),t("p",[e._v("使用参数类型"),t("code",[e._v("ArrayBuffer")]),e._v("对象运行"),t("code",[e._v("send（）")]),e._v("算法描述的步骤。")]),e._v(" "),t("p",[t("code",[e._v("send")])]),e._v(" "),t("p",[e._v("使用参数类型"),t("code",[e._v("ArrayBufferView")]),e._v("对象运行"),t("code",[e._v("send（）")]),e._v("算法描述的步骤。")]),e._v(" "),t("p",[t("code",[e._v("send()")]),e._v("方法被重载，用来处理不同数据参数类型。当该方法的任何版本被调用时，用户代理必须运行下列步骤：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("让channel成为将要发送数据的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。")])]),e._v(" "),t("li",[t("p",[e._v("如果channel的[ReadyState]插槽不为"),t("code",[e._v("open")]),e._v("，抛出"),t("code",[e._v("InvalidStateError")]),e._v("。")])]),e._v(" "),t("li",[t("p",[e._v("执行对应方法参数类型的子步骤：")]),e._v(" "),t("ul",[t("li",[t("p",[t("code",[e._v("string")]),e._v("对象:")]),e._v(" "),t("p",[e._v("让data成为byte buffer，表示将方法参数编码为UTF-8的结果。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("Blob")]),e._v("对象:")]),e._v(" "),t("p",[e._v("让data成为由"),t("code",[e._v("Blob")]),e._v("对象表示的原始数据。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("ArrayBuffer")]),e._v("对象:")]),e._v(" "),t("p",[e._v("让data成为由"),t("code",[e._v("ArrayBuffer")]),e._v("对象描述的存在buffer中的数据。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("ArrayBufferView")]),e._v("对象：")]),e._v(" "),t("p",[e._v("让data成为"),t("code",[e._v("ArrayBufferView")]),e._v("对象提到的"),t("code",[e._v("ArrayBuffer")]),e._v("对象描述的buffer中存储的数据。")])])]),e._v(" "),t("blockquote",[t("p",[e._v("NOTE:任何该方法没有重载的数据类型将会导致"),t("code",[e._v("TypeError")]),e._v("。这包括null和undefined。")])])]),e._v(" "),t("li",[t("p",[e._v("如果data的大小超过了channel的关联"),t("code",[e._v("RTCSctpTransport")]),e._v("上的"),t("code",[e._v("maxMessageSize")]),e._v("的值，抛出"),t("code",[e._v("TypeError")]),e._v("。")])]),e._v(" "),t("li",[t("p",[e._v("对在channel的底层数据传输的data进行排队。")]),e._v(" "),t("blockquote",[t("p",[e._v("NOTE:实际数据传输是并行的。如果发送数据导致SCTP层级的错误，应用程序将会被通过"),t("code",[e._v("onerror")]),e._v("异步通知。")])])]),e._v(" "),t("li",[t("p",[e._v("增加[BufferedAmount]插槽的值，增加量为data的大小。")])])]),e._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[e._v("dictionary "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCDataChannelInit")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n             "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")]),e._v("         ordered "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n             "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EnforceRange")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n             unsigned "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),e._v("  maxPacketLifeTime"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n             "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EnforceRange")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n             unsigned "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),e._v("  maxRetransmits"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n             "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("USVString")]),e._v("       protocol "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('""')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n             "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")]),e._v("         negotiated "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n             "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("EnforceRange")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n             unsigned "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("short")]),e._v("  id"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n             "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCPriorityType")]),e._v(" priority "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"low"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("p",[t("strong",[e._v("字典"),t("code",[e._v("RTCDataChannelInit")]),e._v("成员")])]),e._v(" "),t("p",[e._v("boolean类型的"),t("code",[e._v("ordered")]),e._v("，默认为true:如果设置为false，则允许数据不按顺序传送。默认值为true，保证数据按顺序传递。")]),e._v(" "),t("p",[e._v("unsigned short类型的"),t("code",[e._v("maxPacketLifeTime")]),e._v(":限制通道在未确认的情况下传输或重新传输数据的时间（以毫秒为单位）。如果该值超过用户代理支持的最大值，则可以限制该值。"),t("a",{attrs:{href:"https://github.com/web-platform-tests/wpt/blob/master/webrtc/RTCPeerConnection-createDataChannel.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("测试1"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("unsigned short类型的"),t("code",[e._v("maxRetransmits")]),e._v(":如果未成功传递，则限制通道重新传输数据的次数。如果该值超过用户代理支持的最大值，则可以限制该值。")]),e._v(" "),t("p",[e._v("USVString类型的"),t("code",[e._v("protocol")]),e._v("，默认为"),t("code",[e._v("“”")]),e._v(":用于此通道的子协议名称。")]),e._v(" "),t("p",[e._v("boolean类型的"),t("code",[e._v("negotiated")]),e._v("，默认为"),t("code",[e._v("false")]),e._v(":默认值false指示用户代理在带内通告通道并指示另一个对等方分派相应的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。如果设置为true，则由应用程序协商通道并在另一个对等方创建具有相同ID的"),t("code",[e._v("RTCDataChannel")]),e._v("对象。")]),e._v(" "),t("blockquote",[t("p",[e._v("NOTE:如果设置为true，则应用程序还必须注意不要发送消息，直到另一个对等方创建了一个数据通道来接收它。在没有关联数据通道的SCTP流上接收消息是未定义的行为，可能会以静默方式丢弃。只要两个端点在第一个提议/应答交换完成之前创建其数据通道，就不可能实现这一点。")])]),e._v(" "),t("p",[e._v("unsigned short类型的"),t("code",[e._v("id")]),e._v(":重写此通道的默认ID选择。")]),e._v(" "),t("p",[e._v("RTCPriorityType类型的"),t("code",[e._v("priority")]),e._v("，默认为"),t("code",[e._v("low")]),e._v(":此通道的优先级。")]),e._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("enum")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCDataChannelState")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"connecting"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"open"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"closing"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"closed"')]),e._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),t("table",[t("thead",[t("tr",[t("th",[e._v("RTCDataChannelState枚举描述")]),e._v(" "),t("th")])]),e._v(" "),t("tbody",[t("tr",[t("td",[t("code",[e._v("connecting")])]),e._v(" "),t("td",[e._v("用户代理正在尝试建立底层数据传输。这是"),t("code",[e._v("RTCDataChannel")]),e._v("对象的初始状态，无论是使用"),t("code",[e._v("createDataChannel")]),e._v("创建，还是作为"),t("code",[e._v("RTCDataChannelEvent")]),e._v("的一部分调度。")])]),e._v(" "),t("tr",[t("td",[t("code",[e._v("open")])]),e._v(" "),t("td",[e._v("建立基础数据传输并且可以进行通信。")])]),e._v(" "),t("tr",[t("td",[t("code",[e._v("closing")])]),e._v(" "),t("td",[e._v("关闭底层数据传输的过程已经开始。")])]),e._v(" "),t("tr",[t("td",[t("code",[e._v("closed")])]),e._v(" "),t("td",[e._v("底层数据传输已关闭或无法建立。")])])])])])}),[],!1,null,null,null);a.default=v.exports}}]);