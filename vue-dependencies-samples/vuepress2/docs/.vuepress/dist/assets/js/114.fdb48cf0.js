(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{423:function(t,e,a){"use strict";a.r(e);var _=a(56),s=Object(_.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_8-统计模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-统计模型"}},[t._v("#")]),t._v(" 8 统计模型")]),t._v(" "),a("h2",{attrs:{id:"_8-1简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-1简介"}},[t._v("#")]),t._v(" 8.1简介")]),t._v(" "),a("p",[t._v("基本的统计模型是浏览器以统计对象的形式维护一系列受监控对象的统计信息。")]),t._v(" "),a("p",[t._v("选择器可以引用一组相关对象。例如，选择器可以是"),a("code",[t._v("MediaStreamTrack")]),t._v("。要使track成为有效的选择器，它必须是由发出统计请求的"),a("code",[t._v("RTCPeerConnection")]),t._v("对象发送或接收的"),a("code",[t._v("MediaStreamTrack")]),t._v("。调用Web应用程序为getStats（）方法提供选择器，浏览器根据统计信息选择算法发出（在JavaScript中）与选择器相关的一组统计信息。请注意，该算法采用选择器的发送方或接收方。")]),t._v(" "),a("p",[t._v("stats对象中返回的统计信息的设计方式是重复查询可以由"),a("code",[t._v("RTCStats id")]),t._v("字典成员链接。因此，Web应用程序可以通过在该时段的开始和结束请求测量来在给定时间段内进行测量。")]),t._v(" "),a("p",[t._v("除少数例外情况外，受监控对象一旦创建，就会在其关联的"),a("code",[t._v("RTCPeerConnection")]),t._v("期间存在。这样可以确保getStats（）的结果中的统计信息在关闭的关联对等连接之后可用。")]),t._v(" "),a("p",[t._v("只有少数受监控对象的生命周期较短。对于这些对象，它们的生命周期在被算法删除时结束。在删除时，将在包含RTCStatsReport对象的单个"),a("code",[t._v("statsended")]),t._v("事件中发出其统计信息的记录，该对象包含同时删除的所有对象的统计信息。后续getStats（）结果中不再提供这些对象的统计信息。 [WEBRTC-STATS]中的对象描述描述了何时删除这些受监视对象。")])])}),[],!1,null,null,null);e.default=s.exports}}]);