(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{407:function(e,t,a){"use strict";a.r(t);var s=a(56),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"_5-2-rtcrtpsender-interface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-rtcrtpsender-interface"}},[e._v("#")]),e._v(" 5.2 "),a("code",[e._v("RTCRtpSender")]),e._v(" Interface")]),e._v(" "),a("p",[a("code",[e._v("RTCRtpSender")]),e._v("接口允许应用程序控制给定"),a("code",[e._v("MediaStreamTrack")]),e._v("的编码方式并将其传输到远程对等方。在"),a("code",[e._v("RTCRtpSender")]),e._v("对象上调用"),a("code",[e._v("setParameters")]),e._v("时，编码会相应更改。")]),e._v(" "),a("p",[e._v("要使用"),a("code",[e._v("MediaStreamTrack")]),a("strong",[e._v("创建RTCRtpSender")]),e._v(",跟踪，字符串，种类，"),a("code",[e._v("MediaStream")]),e._v("对象列表，流以及可选的"),a("code",[e._v("RTCRtpEncodingParameters")]),e._v("对象列表，"),a("strong",[e._v("sendEncodings")]),e._v(",请运行以下步骤：")]),e._v(" "),a("ol",[a("li",[e._v("让sender成为新的"),a("code",[e._v("RTCRtpSender")]),e._v("对象。")]),e._v(" "),a("li",[e._v("让sender具有初始化为track的**[[SenderTrack]]**内部插槽。")]),e._v(" "),a("li",[e._v("让sender具有初始化为null的**[[SenderTransport]]**内部插槽。")]),e._v(" "),a("li",[e._v("让sender具有初始化为null的**[[Dtmf]]**内部插槽。")]),e._v(" "),a("li",[e._v("如果种类是"),a("code",[e._v("“audio”")]),e._v("，则创建一个"),a("code",[e._v("RTCDTMFSender")]),e._v(" "),a("strong",[e._v("dtmf")]),e._v("并将[[Dtmf]]内部插槽设置为"),a("strong",[e._v("dtmf")]),e._v("。")]),e._v(" "),a("li",[e._v("让sender具有初始化为null的**[[SenderRtcpTransport]]**内部插槽。")]),e._v(" "),a("li",[e._v("让sender具有一个**[[AssociatedMediaStreamsIds]]**内部插槽，表示此发件人要关联的"),a("code",[e._v("MediaStream")]),e._v("对象的Id列表。如[JSEP] (第5.2.1节)中所述，当发送方在SDP中表示时，使用"),a("code",[e._v("[[AssociatedMediaStreamIds]]")]),e._v("槽。")]),e._v(" "),a("li",[e._v("设置sender的"),a("code",[e._v("[[AssociatedMediaStreamIds]]")]),e._v("为空集合。")]),e._v(" "),a("li",[e._v("对于stream中的所有流，如果不存在则向"),a("code",[e._v("[[AssociatedMediaStreamIds]]")]),e._v("添加stream.id。")]),e._v(" "),a("li",[e._v("让sender具有**[[SendEncodings]]**内部插槽，表示"),a("code",[e._v("RTCRtpEncodingParameters")]),e._v("字典列表。")]),e._v(" "),a("li",[e._v("如果sendEncodings作为算法输入，并且非空，设置[[SendEncodings]]插槽为sendEncodings。否则，设置它为一个列表，包含单一"),a("code",[e._v("RTCRtpEncodingParameters")]),e._v("，并且"),a("code",[e._v("active")]),e._v("设置为"),a("code",[e._v("true")]),e._v("。")]),e._v(" "),a("li",[e._v("让sender具有**[[SendCodecs]]**内部插槽，表示"),a("code",[e._v("RTCRtpCodecParameters")]),e._v("字典列表，并且初始化为空列表。")]),e._v(" "),a("li",[e._v("让sender具有**[[LastReturnedParameters]]**内部插槽，它被用来匹配"),a("code",[e._v("getParameters")]),e._v("和"),a("code",[e._v("setParameters")]),e._v("操作。")]),e._v(" "),a("li",[e._v("返回sender。")])]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Exposed")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Window")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("interface")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCRtpSender")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    readonly        attribute "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MediaStreamTrack")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v(" track"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCDtlsTransport")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v("  transport"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    readonly        attribute "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCDtlsTransport")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v(" rtcpTransport"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCRtpCapabilities")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v(" getCapabilities "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("DOMString")]),e._v(" kind"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Promise")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("             setParameters "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCRtpSendParameters")]),e._v(" parameters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCRtpSendParameters")]),e._v("          getParameters "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Promise")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("             replaceTrack "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MediaStreamTrack")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("?")]),e._v(" withTrack"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v("                            "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("setStreams")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MediaStream")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v(" streams"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Promise")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("RTCStatsReport")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("   "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("getStats")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n\n")])])]),a("p",[a("strong",[e._v("属性")])]),e._v(" "),a("p",[e._v("MediaStreamTrack类型的"),a("code",[e._v("track")]),e._v("，只读，可以为null：")]),e._v(" "),a("p",[a("code",[e._v("track")]),e._v("属性是与此"),a("code",[e._v("RTCRtpSender")]),e._v("对象关联的轨道。如果"),a("code",[e._v("track")]),e._v("结束，或者输出被禁用，即track被禁用和/或静音，则"),a("code",[e._v("RTCRtpSender")]),e._v("必须发送静音(音频)，黑帧(视频)，或零信息内容等效物。在视频的情况下，"),a("code",[e._v("RTCRtpSender")]),e._v("应该每秒发送一个黑帧。如果"),a("code",[e._v("track")]),e._v("为null，则"),a("code",[e._v("RTCRtpSender")]),e._v("不发送。获取时，属性必须返回[[SenderTrack]]插槽的值。")]),e._v(" "),a("p",[a("code",[e._v("RTCDtlsTransport")]),e._v("类型的"),a("code",[e._v("transport")]),e._v("，只读，可以为null：")]),e._v(" "),a("p",[a("code",[e._v("transport")]),e._v("属性是一个传输，在此之上来自"),a("code",[e._v("track")]),e._v("的媒体通过RTP数据包的形式被发送。在"),a("code",[e._v("RTCDtlsTransport")]),e._v("对象构造之前，"),a("code",[e._v("transport")]),e._v("属性将会为null。当使用了绑定，多个"),a("code",[e._v("RTCRtpSender")]),e._v("对象共享一个"),a("code",[e._v("transport")]),e._v("并且都会在相同的传输上发送RTP和RTCP。")]),e._v(" "),a("p",[e._v("获取时，属性必须返回[[SenderTransport]]插槽的值。")]),e._v(" "),a("p",[a("code",[e._v("RTCDtlsTransport")]),e._v("类型的"),a("code",[e._v("rtcpTransport")]),e._v("，只读，可以为null:")]),e._v(" "),a("p",[a("code",[e._v("rtcpTransport")]),e._v("属性是一个传输，在此之上RTCP被发送和接收。在"),a("code",[e._v("RTCDtlsTransport")]),e._v("对象构造之前，"),a("code",[e._v("rtcpTransport")]),e._v("属性将会是null。当多路RTCP复用时，"),a("code",[e._v("rtcpTransport")]),e._v("将会为null，并且RTP和RTCP流都会进入"),a("code",[e._v("transport")]),e._v("描述的传输。")]),e._v(" "),a("p",[e._v("获取时，属性必须返回[[SenderRtcpTransport]]插槽的值。")]),e._v(" "),a("p",[a("strong",[e._v("方法")])]),e._v(" "),a("p",[a("code",[e._v("getCapabilities")]),e._v(", static")]),e._v(" "),a("p",[a("code",[e._v("getCapabilities()")]),e._v("方法返回用于发送指定媒体的系统功能的最优化视图。它不会保存任何资源，端口，或者其它状态，但旨在提供一种方法来发现浏览器的功能类型，包括可能支持的编解码器。用户代理必须支持"),a("code",[e._v('"audio"')]),e._v("和"),a("code",[e._v('"video"')]),e._v("的类型值。如果系统没有与此类型参数值对应的功能，"),a("code",[e._v("getCapabilities")]),e._v("返回"),a("code",[e._v("null")]),e._v("。")]),e._v(" "),a("p",[e._v("这些功能通常在设备上提供持久的跨源信息，从而增加了应用程序的指纹表面。在隐私敏感的上下文中，浏览器可能考虑缓解，例如仅报告功能的公共子集。")]),e._v(" "),a("p",[a("code",[e._v("setParameters")])]),e._v(" "),a("p",[a("code",[e._v("setParameters")]),e._v("方法更新"),a("code",[e._v("track")]),e._v("如何编码并传输到远程对等端。")]),e._v(" "),a("p",[e._v("当调用"),a("code",[e._v("setParameters")]),e._v("方法时，用户代理必须运行以下步骤：")]),e._v(" "),a("ol",[a("li",[e._v("让parameters成为方法的第一个参数。")]),e._v(" "),a("li",[e._v("让sender成为调用"),a("code",[e._v("setParameters")]),e._v("的"),a("code",[e._v("RTCRtpSender")]),e._v("对象。")]),e._v(" "),a("li",[e._v("让transceiver成为与sender关联的"),a("code",[e._v("RTCRtpTransceiver")]),e._v("对象、")]),e._v(" "),a("li",[e._v("如果transceiver的[[Stopped]]插槽为"),a("code",[e._v("true")]),e._v("，返回一个promise，reject为一个新创建的"),a("code",[e._v("InvalidStateError")]),e._v("。")]),e._v(" "),a("li",[e._v("如果sender的[[LastReturnedParameters]]内部插槽为"),a("code",[e._v("null")]),e._v("，返回一个promise，reject为新创建的"),a("code",[e._v("InvalidStateError")]),e._v("。")]),e._v(" "),a("li",[e._v("通过以下步骤验证parameter：\n"),a("ol",[a("li",[e._v("让encodings为"),a("code",[e._v("parameters.encodings")]),e._v("。")]),e._v(" "),a("li",[e._v("让codecs为"),a("code",[e._v("parameters.codecs")]),e._v("。")]),e._v(" "),a("li",[e._v("让N为存储在sender的内部插槽[[SendEncodings]]中的"),a("code",[e._v("RTCRtpEncodingParameters")]),e._v("数量。")]),e._v(" "),a("li",[e._v("如果符合以下条件任意之一，返回一个promise，reject为新创建的"),a("code",[e._v("InvalidModificationError")]),e._v(":\n"),a("ol",[a("li",[a("code",[e._v("encodings.length")]),e._v("与N不同。")]),e._v(" "),a("li",[e._v("encodings已经被重新排序。")]),e._v(" "),a("li",[e._v("parameters中的任何参数被标记为只读参数(例如RID)，并且具有与相应sender的[[LastReturnedParameters]]内部插槽不同的值。注意这对transactionId同样有效。")])])]),e._v(" "),a("li",[e._v("验证encodings中的每个"),a("code",[e._v("scaleResolutionDownBy")]),e._v("值大于等于1.0。如果任意一个值不满足条件，返回一个promise，reject为新创建的"),a("code",[e._v("RangeError")]),e._v("。")]),e._v(" "),a("li",[e._v("验证encodings中的每个"),a("code",[e._v("maxFramerate")]),e._v("值大于等于0.0。如果其中一个值不满足条件，返回一个承诺，reject为新创建的"),a("code",[e._v("RangeError")]),e._v("。")])])]),e._v(" "),a("li",[e._v("让p成为一个新的promise。")]),e._v(" "),a("li",[e._v("同时，配置媒体栈来使用parameters传输sender的[[SenderTrack]]。\n"),a("ol",[a("li",[e._v("如果使用parameters成功配置了媒体栈，对任务进行排序，允许下列步骤：\n"),a("ol",[a("li",[e._v("让sender的内部[[LastReturnedParameters]]插槽为null。")]),e._v(" "),a("li",[e._v("让sender的内部[[SendEncodings]]插槽为"),a("code",[e._v("parameters.encodings")]),e._v("。")]),e._v(" "),a("li",[e._v("解析p为undefined。")])])]),e._v(" "),a("li",[e._v("如果配置媒体栈的时候出现了error，排序任务运行以下步骤：\n"),a("ol",[a("li",[e._v("如果由于硬件资源不可用引发error，reject p为新创建的"),a("code",[e._v("RTCError")]),e._v(",它的"),a("code",[e._v("errorDetail")]),e._v('被设置为"硬件编码器不可用"，并且中断这些步骤。')]),e._v(" "),a("li",[e._v("如果由于硬件编码器不支持parameters引发error，reject p为新创建的"),a("code",[e._v("RTCError")]),e._v(",它的"),a("code",[e._v("errorDetail")]),e._v('被设置为"硬件编码器错误"并且中断这些步骤。')]),e._v(" "),a("li",[e._v("其它错误，reject p为新创建的"),a("code",[e._v("OperationError")]),e._v("。")])])])])]),e._v(" "),a("li",[e._v("返回p。")])]),e._v(" "),a("p",[a("code",[e._v("setParameters")]),e._v("不会导致SDP重新协商，只能被用于更改媒体栈在由Offer/Answer协商的信封中发送或接收的内容。"),a("code",[e._v("RTCRtpSendParameters")]),e._v("字典中的属性旨在不启用此属性，因此像"),a("code",[e._v("cname")]),e._v("之类无法更改的属性是只读的。另外，像比特率，由"),a("code",[e._v("maxBitrate")]),e._v("之类的界限控制，此处用户代理需要确保没有超出"),a("code",[e._v("maxBitrate")]),e._v("指定的最大比特率，同时确保它满足其它例如SDP的地方指定的对比特率的限制。")]),e._v(" "),a("p",[a("code",[e._v("getParameters")])]),e._v(" "),a("p",[a("code",[e._v("getParameters()")]),e._v("方法返回"),a("code",[e._v("RTCRtpSender")]),e._v("对象当前参数，此参数表示"),a("code",[e._v("track")]),e._v("是如何编码并传输到远程"),a("code",[e._v("RTCRtpReceiver")]),e._v("。")]),e._v(" "),a("p",[e._v("当调用"),a("code",[e._v("getParameters")]),e._v("时，"),a("code",[e._v("RTCRtpSendParameters")]),e._v("字典构造如下：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("transactionId")]),e._v("被设置为新的独特Id,被用来将此次"),a("code",[e._v("getParameters")]),e._v("调用与将来可能会出现的"),a("code",[e._v("setParameters")]),e._v("调用匹配。")]),e._v(" "),a("li",[a("code",[e._v("encodings")]),e._v("被设置为[[SendEncodings]]内部插槽的值。")]),e._v(" "),a("li",[a("code",[e._v("headerExtensions")]),e._v("序列根据已协商发送的标头扩展名进行填充。")]),e._v(" "),a("li",[a("code",[e._v("codecs")]),e._v("被设置为[[SendCodecs]]内部插槽的值。")]),e._v(" "),a("li",[a("code",[e._v("rtcp.cname")]),e._v("被设置为关联"),a("code",[e._v("RTCPeerConnection")]),e._v("的CNAME。"),a("code",[e._v("rtcp.reducedSize")]),e._v("被设置为"),a("code",[e._v("true")]),e._v("，如果reduced-size RTCP已经被协商发送，否则为"),a("code",[e._v("false")]),e._v("。")]),e._v(" "),a("li",[a("code",[e._v("degradationPreference")]),e._v("被设置为传入"),a("code",[e._v("setParameters")]),e._v("的最后一个值，如果"),a("code",[e._v("setParameters")]),e._v('还未调用，则设置为默认值"balanced"。')])]),e._v(" "),a("p",[e._v("返回的"),a("code",[e._v("RTCRtpSendParameters")]),e._v("字典必须存入"),a("code",[e._v("RTCRtpSender")]),e._v("对象的[[LastReturnedParameters]]内部插槽。")]),e._v(" "),a("p",[e._v("getParameters可能与setParameters并用，更改参数：")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[e._v("async function "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("updateParameters")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("try")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" params "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" sender"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("getParameters")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// ... make changes to parameters")]),e._v("\n    params"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("encodings"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("active "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    await sender"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("setParameters")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("params"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("catch")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("err"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("err"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("在对"),a("code",[e._v("setParameters")]),e._v("的完全调用后，后续对"),a("code",[e._v("getParameters")]),e._v("调用将会返回修改后的参数集合。")]),e._v(" "),a("p",[a("code",[e._v("replaceTrack")])]),e._v(" "),a("p",[e._v("试图将"),a("code",[e._v("RTCRtpSender")]),e._v("当前的"),a("code",[e._v("track")]),e._v("替换为指定的track，而不需要重新协商。")]),e._v(" "),a("p",[e._v("当"),a("code",[e._v("replaceTrack")]),e._v("方法被调用时，用户代理必须运行以下步骤：")]),e._v(" "),a("ol",[a("li",[e._v("让sender成为"),a("code",[e._v("RTCRtpSender")]),e._v("对象，并在此对象上调用"),a("code",[e._v("replaceTrack")]),e._v("。")]),e._v(" "),a("li",[e._v("让transceiver成为与sender关联的"),a("code",[e._v("RTCRtpTransceiver")]),e._v("对象。")]),e._v(" "),a("li",[e._v("让connection成为与sender关联的"),a("code",[e._v("RTCPeerConnection")]),e._v("对象。")]),e._v(" "),a("li",[e._v("让withTrack成为方法参数。")]),e._v(" "),a("li",[e._v("如果"),a("code",[e._v("withTrack")]),e._v("不为null，并且"),a("code",[e._v("withTrack.kind")]),e._v("与transceiver的transceiver类别不同，返回一个promise，reject为新创建的"),a("code",[e._v("TypeError")]),e._v(".")]),e._v(" "),a("li",[e._v("返回将下列步骤加入connection的运行队列之后的结果：\n"),a("ol",[a("li",[e._v("如果transceiver的[[Stopped]]插槽为true，返回一个promise，reject为新创建的"),a("code",[e._v("InvalidStateError")]),e._v("。")]),e._v(" "),a("li",[e._v("让p成为新的promise。")]),e._v(" "),a("li",[e._v("让sending为"),a("code",[e._v("true")]),e._v("，如果transceiver的[[CurrentDirection]]是"),a("code",[e._v('"sendrecv"')]),e._v("或"),a("code",[e._v('"sendonly"')]),e._v("，否则为"),a("code",[e._v("false")]),e._v("。")]),e._v(" "),a("li",[e._v("并行运行以下步骤：\n"),a("ol",[a("li",[e._v("如果sending为"),a("code",[e._v("true")]),e._v("，并且withTrack为"),a("code",[e._v("null")]),e._v("，使sender停止发送。")]),e._v(" "),a("li",[e._v("如果sending为"),a("code",[e._v("true")]),e._v("，withTrack不为"),a("code",[e._v("null")]),e._v("，确定withTrack是否可以由发送方立即发送而不违反发送方协商好的信封，如果不能，则reject p为新创建的"),a("code",[e._v("InvalidModificationError")]),e._v("，并中断这些步骤。")]),e._v(" "),a("li",[e._v("如果sending为"),a("code",[e._v("true")]),e._v("，withTrack不为"),a("code",[e._v("null")]),e._v("，让发送方无缝切换到传输withTrack，而不是sender现存的track。")]),e._v(" "),a("li",[e._v("对任务进行排序，运行以下步骤：\n"),a("ol",[a("li",[e._v("如果connection的[[IsClosed]]插槽为"),a("code",[e._v("true")]),e._v("，中断下列步骤。")]),e._v(" "),a("li",[e._v("设置sender的"),a("code",[e._v("track")]),e._v("属性为withTrack。")]),e._v(" "),a("li",[e._v("用"),a("code",[e._v("undefined")]),e._v("解析p。")])])])])]),e._v(" "),a("li",[e._v("返回p。")])])])]),e._v(" "),a("blockquote",[a("p",[e._v("NOTE:改变尺寸和/或帧率可能不需要协商。可能需要协商的情形包括:")]),e._v(" "),a("ol",[a("li",[e._v("将分辨率改为超出协商好的imageattr边界的值，如[RFC6236]中所述。")]),e._v(" "),a("li",[e._v("将帧率改为导致编码器block rate超出的值。")]),e._v(" "),a("li",[e._v("视频轨道与原始格式和预编码格式不同。")]),e._v(" "),a("li",[e._v("音轨具有不同数量的通道数。")]),e._v(" "),a("li",[e._v("同样编码的源(通常是硬件编码器)可能无法生成协商的编解码器；类似的，软件源可能不会实现为编码源协商的编解码器。")])])]),e._v(" "),a("p",[a("code",[e._v("setStreams")])]),e._v(" "),a("p",[e._v("设置"),a("code",[e._v("MediaStreams")]),e._v("与sender的track相关联。")]),e._v(" "),a("p",[e._v("当"),a("code",[e._v("setStreams")]),e._v("方法被调用后，用户代理必须运行以下步骤：")]),e._v(" "),a("ol",[a("li",[e._v("让sender成为调用方法的"),a("code",[e._v("RTCRtpSender")]),e._v("对象。")]),e._v(" "),a("li",[e._v("让connection成为调用方法的"),a("code",[e._v("RTCPeerConnection")]),e._v("对象。")]),e._v(" "),a("li",[e._v("如果connection的[[IsClosed]]插槽为"),a("code",[e._v("true")]),e._v("，抛出"),a("code",[e._v("InvalidStateError")]),e._v("。")]),e._v(" "),a("li",[e._v("让streams成为通过方法参数构建的MediaStream对象列表，如果方法没有传入参数被调用，则设置为空列表。")]),e._v(" "),a("li",[e._v("设置sender的[[AssociatedMediaStreamIds]]为空集合。")]),e._v(" "),a("li",[e._v("对于streams中的流，如果未存在则向[[AssocaitedMediaStreamIds]]中添加stream.id。")]),e._v(" "),a("li",[e._v("更新连接的negotiation-needed 标记。")])]),e._v(" "),a("p",[a("code",[e._v("getStats")])]),e._v(" "),a("p",[e._v("仅收集发送方的统计信息，并异步报告结果。")]),e._v(" "),a("p",[e._v("当调用"),a("code",[e._v("getStats()")]),e._v("后，用户代理必须运行以下步骤：")]),e._v(" "),a("ol",[a("li",[e._v("让selector成为调用方法的"),a("code",[e._v("RTCRtpSender")]),e._v("对象。")]),e._v(" "),a("li",[e._v("让p成为新的promise，并行运行以下步骤：\n"),a("ol",[a("li",[e._v("根据统计选择算法收集selector指定的统计信息。")]),e._v(" "),a("li",[e._v("使用"),a("code",[e._v("RTCStatsReport")]),e._v("对象解析p，包含收集到的统计信息。")])])]),e._v(" "),a("li",[e._v("返回p。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);