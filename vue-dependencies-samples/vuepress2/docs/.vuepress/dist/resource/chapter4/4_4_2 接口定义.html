<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>4.4.2 接口定义 | 大大的标题</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="这是一个描述">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="../assets/css/0.styles.2b7c72d0.css" as="style"><link rel="preload" href="../assets/js/app.cdf1d230.js" as="script"><link rel="preload" href="../assets/js/2.a9f4ac6f.js" as="script"><link rel="preload" href="../assets/js/44.f12c7850.js" as="script"><link rel="prefetch" href="../assets/js/10.e16cac7a.js"><link rel="prefetch" href="../assets/js/100.548e1455.js"><link rel="prefetch" href="../assets/js/101.24abf376.js"><link rel="prefetch" href="../assets/js/102.9eb21f1d.js"><link rel="prefetch" href="../assets/js/103.f8ec6c60.js"><link rel="prefetch" href="../assets/js/104.a716a17a.js"><link rel="prefetch" href="../assets/js/105.7b79881a.js"><link rel="prefetch" href="../assets/js/106.d36568a9.js"><link rel="prefetch" href="../assets/js/107.a8f24113.js"><link rel="prefetch" href="../assets/js/108.ad8550dd.js"><link rel="prefetch" href="../assets/js/109.75ebdb1c.js"><link rel="prefetch" href="../assets/js/11.c459fe4f.js"><link rel="prefetch" href="../assets/js/110.a167ec03.js"><link rel="prefetch" href="../assets/js/111.264c1605.js"><link rel="prefetch" href="../assets/js/112.85ecd3af.js"><link rel="prefetch" href="../assets/js/113.527d6a16.js"><link rel="prefetch" href="../assets/js/114.fdb48cf0.js"><link rel="prefetch" href="../assets/js/115.26e4a7c6.js"><link rel="prefetch" href="../assets/js/116.7e019b64.js"><link rel="prefetch" href="../assets/js/117.d0e550a3.js"><link rel="prefetch" href="../assets/js/118.74295340.js"><link rel="prefetch" href="../assets/js/119.915bd419.js"><link rel="prefetch" href="../assets/js/12.b37335e5.js"><link rel="prefetch" href="../assets/js/120.e137f15b.js"><link rel="prefetch" href="../assets/js/121.20503efe.js"><link rel="prefetch" href="../assets/js/122.8dd1bd99.js"><link rel="prefetch" href="../assets/js/123.439150a2.js"><link rel="prefetch" href="../assets/js/124.63b1bd33.js"><link rel="prefetch" href="../assets/js/125.273c90da.js"><link rel="prefetch" href="../assets/js/126.9a4a073a.js"><link rel="prefetch" href="../assets/js/127.5fcb88fd.js"><link rel="prefetch" href="../assets/js/128.cbc0ca1c.js"><link rel="prefetch" href="../assets/js/13.90ab8b63.js"><link rel="prefetch" href="../assets/js/14.3c27acc0.js"><link rel="prefetch" href="../assets/js/15.4c125fea.js"><link rel="prefetch" href="../assets/js/16.4488f96f.js"><link rel="prefetch" href="../assets/js/17.2f2ff4ba.js"><link rel="prefetch" href="../assets/js/18.306a9a94.js"><link rel="prefetch" href="../assets/js/19.2cdf0f8d.js"><link rel="prefetch" href="../assets/js/20.34221d1f.js"><link rel="prefetch" href="../assets/js/21.a9131b3b.js"><link rel="prefetch" href="../assets/js/22.3f8ed5d5.js"><link rel="prefetch" href="../assets/js/23.c032ef30.js"><link rel="prefetch" href="../assets/js/24.6ec163bb.js"><link rel="prefetch" href="../assets/js/25.ab48889a.js"><link rel="prefetch" href="../assets/js/26.bc43105e.js"><link rel="prefetch" href="../assets/js/27.00298855.js"><link rel="prefetch" href="../assets/js/28.da80b56e.js"><link rel="prefetch" href="../assets/js/29.60653b22.js"><link rel="prefetch" href="../assets/js/3.e423e0c9.js"><link rel="prefetch" href="../assets/js/30.3b75298a.js"><link rel="prefetch" href="../assets/js/31.4adb85a8.js"><link rel="prefetch" href="../assets/js/32.14005d42.js"><link rel="prefetch" href="../assets/js/33.63332c10.js"><link rel="prefetch" href="../assets/js/34.c17d7de5.js"><link rel="prefetch" href="../assets/js/35.3d4c33cf.js"><link rel="prefetch" href="../assets/js/36.a266397a.js"><link rel="prefetch" href="../assets/js/37.43901b27.js"><link rel="prefetch" href="../assets/js/38.d8edd2b4.js"><link rel="prefetch" href="../assets/js/39.d8aa5513.js"><link rel="prefetch" href="../assets/js/4.84ff89bd.js"><link rel="prefetch" href="../assets/js/40.bd57e5ae.js"><link rel="prefetch" href="../assets/js/41.59f75ee2.js"><link rel="prefetch" href="../assets/js/42.15597946.js"><link rel="prefetch" href="../assets/js/43.0856031f.js"><link rel="prefetch" href="../assets/js/45.3011fda6.js"><link rel="prefetch" href="../assets/js/46.fea77535.js"><link rel="prefetch" href="../assets/js/47.7547dc9d.js"><link rel="prefetch" href="../assets/js/48.24621e3a.js"><link rel="prefetch" href="../assets/js/49.71870b9a.js"><link rel="prefetch" href="../assets/js/5.d9c28746.js"><link rel="prefetch" href="../assets/js/50.1d4e7900.js"><link rel="prefetch" href="../assets/js/51.af831802.js"><link rel="prefetch" href="../assets/js/52.04638f89.js"><link rel="prefetch" href="../assets/js/53.7e7f96b0.js"><link rel="prefetch" href="../assets/js/54.8588306e.js"><link rel="prefetch" href="../assets/js/55.a9c644b5.js"><link rel="prefetch" href="../assets/js/56.cafe1e71.js"><link rel="prefetch" href="../assets/js/57.7ac51837.js"><link rel="prefetch" href="../assets/js/58.b37aa35b.js"><link rel="prefetch" href="../assets/js/59.351187d5.js"><link rel="prefetch" href="../assets/js/6.3b9d4d26.js"><link rel="prefetch" href="../assets/js/60.dcc9d9f5.js"><link rel="prefetch" href="../assets/js/61.bacf7351.js"><link rel="prefetch" href="../assets/js/62.63d3b2ed.js"><link rel="prefetch" href="../assets/js/63.b324469c.js"><link rel="prefetch" href="../assets/js/64.846fa177.js"><link rel="prefetch" href="../assets/js/65.f183f0d9.js"><link rel="prefetch" href="../assets/js/66.e57d84a3.js"><link rel="prefetch" href="../assets/js/67.a25869ed.js"><link rel="prefetch" href="../assets/js/68.f1f81331.js"><link rel="prefetch" href="../assets/js/69.b920e71a.js"><link rel="prefetch" href="../assets/js/7.910c14e3.js"><link rel="prefetch" href="../assets/js/70.1b577ef6.js"><link rel="prefetch" href="../assets/js/71.4bd5f658.js"><link rel="prefetch" href="../assets/js/72.dd85b786.js"><link rel="prefetch" href="../assets/js/73.bb4387f4.js"><link rel="prefetch" href="../assets/js/74.da18a018.js"><link rel="prefetch" href="../assets/js/75.94cae234.js"><link rel="prefetch" href="../assets/js/76.10887417.js"><link rel="prefetch" href="../assets/js/77.5962f0b8.js"><link rel="prefetch" href="../assets/js/78.800340dc.js"><link rel="prefetch" href="../assets/js/79.4e83e76a.js"><link rel="prefetch" href="../assets/js/8.c7b4ad32.js"><link rel="prefetch" href="../assets/js/80.4af391f9.js"><link rel="prefetch" href="../assets/js/81.3feab326.js"><link rel="prefetch" href="../assets/js/82.947e005d.js"><link rel="prefetch" href="../assets/js/83.da4cc36d.js"><link rel="prefetch" href="../assets/js/84.b1c8a6c6.js"><link rel="prefetch" href="../assets/js/85.fc9f92b9.js"><link rel="prefetch" href="../assets/js/86.7f7d1c9d.js"><link rel="prefetch" href="../assets/js/87.1e12046a.js"><link rel="prefetch" href="../assets/js/88.f0e0ca94.js"><link rel="prefetch" href="../assets/js/89.f1535b0d.js"><link rel="prefetch" href="../assets/js/9.3ec2836b.js"><link rel="prefetch" href="../assets/js/90.a7deffda.js"><link rel="prefetch" href="../assets/js/91.5911af9f.js"><link rel="prefetch" href="../assets/js/92.d0f4335a.js"><link rel="prefetch" href="../assets/js/93.d636f560.js"><link rel="prefetch" href="../assets/js/94.dbba3a1b.js"><link rel="prefetch" href="../assets/js/95.d4d6ca02.js"><link rel="prefetch" href="../assets/js/96.39fa0625.js"><link rel="prefetch" href="../assets/js/97.fba26ae0.js"><link rel="prefetch" href="../assets/js/98.94a9e4f3.js"><link rel="prefetch" href="../assets/js/99.c3c2ebe6.js">
    <link rel="stylesheet" href="../assets/css/0.styles.2b7c72d0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/../" class="home-link router-link-active"><img src="https://xiao-akatsuki.github.io/axios.org/logo/logo.svg" alt="大大的标题" class="logo"> <span class="site-name can-hide">大大的标题</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/xiao-akatsuki/axios" target="_blank" rel="noopener noreferrer" class="repo-link">
    axios
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/xiao-akatsuki/axios" target="_blank" rel="noopener noreferrer" class="repo-link">
    axios
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="_4-4-2-接口定义"><a href="#_4-4-2-接口定义" class="header-anchor">#</a> <a href="http://w3c.github.io/webrtc-pc/#interface-definition" target="_blank" rel="noopener noreferrer">4.4.2 接口定义<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>本节中介绍的 RTCPeerConnection 接口通过本规范中的几个部分接口进行了扩展。值得注意的是，RTP Media API部分添加了 API 以发送和接收 MediaStreamTrack 对象。</p> <div class="language- extra-class"><pre class="language-text"><code>[Constructor(optional RTCConfiguration configuration),
  Exposed=Window]
interface RTCPeerConnection : EventTarget {
  Promise&lt;RTCSessionDescriptionInit&gt; createOffer(optional RTCOfferOptions options);
  Promise&lt;RTCSessionDescriptionInit&gt; createAnswer(optional RTCAnswerOptions options);
  Promise&lt;void&gt; setLocalDescription(RTCSessionDescriptionInit description);
  readonly attribute RTCSessionDescription? localDescription;
  readonly attribute RTCSessionDescription? currentLocalDescription;
  readonly attribute RTCSessionDescription? pendingLocalDescription;
  Promise&lt;void&gt; setRemoteDescription(RTCSessionDescriptionInit description);
  readonly attribute RTCSessionDescription? remoteDescription;
  readonly attribute RTCSessionDescription? currentRemoteDescription;
  readonly attribute RTCSessionDescription? pendingRemoteDescription;
  Promise&lt;void&gt; addIceCandidate(RTCIceCandidateInit candidate);
  readonly attribute RTCSignalingState signalingState;
  readonly attribute RTCIceGatheringState iceGatheringState;
  readonly attribute RTCIceConnectionState iceConnectionState;
  readonly attribute RTCPeerConnectionState connectionState;
  readonly attribute boolean? canTrickleIceCandidates;
  static sequence&lt;RTCIceServer&gt; getDefaultIceServers();
  RTCConfiguration getConfiguration();
  void setConfiguration(RTCConfiguration configuration);
  void close();
  attribute EventHandler onnegotiationneeded;
  attribute EventHandler onicecandidate;
  attribute EventHandler onicecandidateerror;
  attribute EventHandler onsignalingstatechange;
  attribute EventHandler oniceconnectionstatechange;
  attribute EventHandler onicegatheringstatechange;
  attribute EventHandler onconnectionstatechange;
};

</code></pre></div><h5 id="构造函数"><a href="#构造函数" class="header-anchor">#</a> 构造函数</h5> <p><em><code>RTCPeerConnection</code></em></p> <p>请参阅 <a href="/../resource/chapter4/4_4_1_1 构造函数.html">RTCPeerConnection 构造函数算法</a>。</p> <h5 id="属性"><a href="#属性" class="header-anchor">#</a> 属性</h5> <p>**<code>localDescription</code>**类型 RTCSessionDescription，只读，不能为空：</p> <p>如果 localDescription 属性不为 null，则它必须返回[[PendingLocalDescription]]，否则它必须返回[[CurrentLocalDescription]]。</p> <p>注意[[CurrentLocalDescription]].sdp和[[PendingLocalDescription]].sdp不需要与传递给相应 setLocalDescription 调用的 SDP 值完全相同（即 SDP 可以被解析和重新格式化，并且可以添加 ICE 候选者） 。</p> <p>**<code>currentLocalDescription</code>**类型为 RTCSessionDescription，只读，不能为空：</p> <p>currentLocalDescription 属性必须返回[[CurrentLocalDescription]]。</p> <p>它表示上次 RTCPeerConnection 转换为稳定状态时成功协商的本地描述，以及自创建 offer 或 answer 以来 ICE 代理生成的任何本地候选项。</p> <p>**<code>pendingLocalDescription</code>**类型为 RTCSessionDescription，只读，不能为空：</p> <p>pendingLocalDescription 属性必须返回[[PendingLocalDescription]]。</p> <p>它表示正在协商的本地描述以及自创建 offer 或 answer 以来 ICE 代理生成的任何本地候选人。如果 RTCPeerConnection 处于稳定状态，则该值为空。</p> <p>**<code>remoteDescription</code>**类型 RTCSessionDescription，只读，不能为空：</p> <p>remoteDescription 属性必须返回[[PendingRemoteDescription]]，如果它不为 null，否则它必须返回[[CurrentRemoteDescription]]。</p> <p>注意[[CurrentRemoteDescription]].sdp和[[PendingRemoteDescription]].sdp 不需要与传递给相应的 setRemoteDescription 调用的 SDP 值完全相同（即 SDP 可以被解析和重新格式化，并且可以添加 ICE 候选者） 。</p> <p>**<code>currentRemoteDescription</code>**类型为RTCSessionDescription，只读，不能为空：</p> <p>currentRemoteDescription 属性必须返回[[CurrentRemoteDescription]]。</p> <p>它表示上次 RTCPeerConnection 转换为稳定状态时成功协商的最后一个远程描述，以及自创建 offer 或 answer 以来通过addIceCandidate（）提供的任何远程候选。</p> <p>**<code>pendingRemoteDescription</code>**类型RTCSessionDescription，只读，不能为空：</p> <p>pendingRemoteDescription 属性必须返回[[PendingRemoteDescription]]。</p> <p>它表示正在协商过程中的远程描述，包括自创建 offer 或 answer 以来通过 addIceCandidate（）提供的任何远程候选项。如果 RTCPeerConnection 处于稳定状态，则该值为空。</p> <p>TRANSPCS 类型为 RTCSignalingState 的 signalingState， 只读:</p> <p>signalingState 属性必须返回 RTCPeerConnection 对象的信令状态。</p> <p>**<code>iceGatheringState</code>**类型为RTCIceGatheringState，只读</p> <p>iceGatheringState 属性必须返回 RTCPeerConnection 实例的 ICE 收集状态。</p> <p>**<code>RTCIceConnectionState</code>**类型的iceConnectionState，只读</p> <p>iceConnectionState 属性必须返回 RTCPeerConnection 实例的 ICE 连接状态。</p> <p>类型为RTCPeerConnectionState的connectionState，只读：</p> <p>connectionState 属性必须返回 RTCPeerConnection 实例的连接状态。</p> <p>canTrickleIceCandidates类型为boolean，只读，不能为空：</p> <p>The canTrickleIceCandidates attribute indicates whether the remote peer is able to accept trickled ICE candidates [TRICKLE-ICE]. The value is determined based on whether a remote description indicates support for trickle ICE, as defined in [JSEP] (section 4.1.15.). Prior to the completion of setRemoteDescription, this value is null.</p> <p>canTrickleIceCandidates 属性指示远程对等方是否能够接受 trickle ICE 候选[TRICKLE-ICE]。该值是根据远程描述是否表示支持 trickle ICE 确定的，如[JSEP]（第4.1.15节）中所定义。在完成 setRemoteDescription 之前，此值为 null。</p> <p>onnegotiationneeded 类型 EventHandler</p> <p>此事件处理程序的事件类型是 negotiationneeded。</p> <p>eventHandler 类型的 onicecandidate</p> <p>此事件处理程序的事件类型是 icecandidate。</p> <p>eventHandler 类型的 onicecandidateerror</p> <p>此事件处理程序的事件类型是 icecandidateerror。</p> <p>onSignalingstate 类型 EventHandler 的更改</p> <p>此事件处理程序的事件类型是 signalingstatechange。</p> <p>eventHandler 类型的 oniceconnectionstatechange</p> <p>此事件处理程序的事件类型是 iceconnectionstatechange</p> <p>eventHandler 类型的 onicegatheringstatechange</p> <p>此事件处理程序的事件类型是 icegatheringstatechange。</p> <p>eventHandler 类型的 onconnectionstatechange</p> <p>此事件处理程序的事件类型是 connectionstatechange。</p> <h5 id="方法"><a href="#方法" class="header-anchor">#</a> 方法</h5> <p><code>createOffer</code></p> <p>createOffer 方法生成一个 SDP blob，其中包含 RFC 3264 offer，其中包含会话支持的配置，包括附加到此 RTCPeerConnection 的本地 MediaStreamTracks 的说明，此实现支持的编解码器/ RTP / RTCP 功能以及 ICE 的参数代理和 DTLS 连接。可以提供选项参数以提供对所生成的 offer 的额外控制。</p> <p>如果系统具有有限的资源（例如，有限数量的解码器），则 createOffer 需要返回反映系统当前状态的 offer，以便 setLocalDescription 在尝试获取这些资源时成功。会话描述必须仍然可以通过 setLocalDescription 保持可用，而不会导致错误，直到至少返回的 promise 的履行回调结束。</p> <p>创建 SDP 必须遵循适当的流程来生成[JSEP]中描述的 offer。作为要约，生成的 SDP 将包含会话支持或优选的全套编解码器/ RTP / RTCP功能（而不是 answer，其将仅包括要使用的特定协商子集）。如果在建立会话后调用 createOffer，createOffer 将生成与当前会话兼容的 offer，其中包含自上次完成 offer - 应答交换以来对会话所做的任何更改，例如添加或删除轨道。如果未进行任何更改，则要约将包括当前本地描述的功能以及可在更新的要约中协商的任何其他功能。</p> <p>生成 SDP还将包含 ICE 代理的 usernameFragment，密码和 ICE 选项（在[ICE]，第14节中定义），还可以包含代理收集的任何本地候选。</p> <p>RTCPeerConnection 的配置中的证书值提供了应用程序为 RTCPeerConnection 配置的证书。这些证书以及任何默认证书用于生成一组证书指纹。这些证书指纹用于构建 SDP 和作为身份断言请求的输入。</p> <p>如果 RTCPeerConnection 配置为通过调用 setIdentityProvider 生成 Identity 断言，则会话描述应包含适当的断言。</p> <p>生成 SDP 的过程暴露了底层系统的媒体功能的子集，其在设备上提供通常持久的跨源信息。因此，它增加了应用的指纹表面。在隐私敏感的上下文中，浏览器可以考虑缓解，例如仅生成 SDP 匹配功能的公共子集。</p> <p>调用该方法时，用户代理必须执行以下步骤：</p> <p>让connection 成为调用方法的 RTCPeerConnection 对象。</p> <p>如果connection的[[IsClosed]] 值为 true，则返回使用新创建的 InvalidStateError 拒绝的 promise。</p> <p>如果使用身份提供程序配置连接，则在尚未开始的情况下开始身份声明请求过程。</p> <p>将以下步骤的结果返回到连接的操作队列：</p> <p>让p成为新的Promise。</p> <p>同时，在给定 p 的情况下，开始创建 offer 的步骤。</p> <p>返回p。</p> <p>在给定承诺 p 的情况下创建要约的步骤如下：</p> <p>如果未使用一组证书构建连接，并且尚未生成一个证书，请等待生成。</p> <p>如果已配置提供者，则提供者是连接的当前配置身份提供者，否则为 null。</p> <p>如果 provider 为非 null，则等待身份断言请求过程完成。</p> <p>如果提供程序无法生成标识声明，请使用新创建的 NotReadableError 拒绝 p 并中止这些步骤。</p> <p>检查系统状态以确定生成要约所需的当前可用资源，如[JSEP]（第4.1.6节）中所述。</p> <p>如果此检查因任何原因失败，请使用新创建的 OperationError 拒绝p并中止这些步骤。</p> <p>在给定 p 的情况下，对运行最终步骤以创建 offer 的任务进行排队。</p> <p>给出承诺 p 创建要约的最后步骤如下：</p> <p>如果connection的[[IsClosed]] 值为true，则中止这些步骤。</p> <p>如果以这样的方式修改连接，即需要对系统状态进行额外检查，或者如果其配置的 indentity 提供程序不再是提供者，则并行开始执行再次创建 offer 的步骤，给定 p，并中止这些步骤。</p> <p>NOTE：如果仅在连接中添加了音频RTCRtpTransceiver时调用了createOffer，但在执行并行创建 offer的步骤时，可能需要添加视频RTCRtpTransceiver，这需要额外检查视频系统资源。</p> <p>给定从先前检查获得的信息，当前连接状态及其 RTCRtpTransceivers，以及来自提供者的身份断言（如果非空），生成 SDP offer sdpString，如[JSEP]（第5.2节）中所述。</p> <p>如[捆绑]（第7节）中所述，如果使用捆绑（请参阅RTCBundlePolicy），则必须选择标记为 m = section 的提议者才能协商 BUNDLE 组。用户代理必须选择 m = 部分，该部分对应于收发器集合中的第一个不停止的收发器，作为提供者标记的 m = 部分。这允许远程端点预测哪个收发器是提供者标记的 m = 部分而不必解析 SDP。</p> <p>m = 段的相关收发器的编解码器首选项被称为 RTCRtpTranceiver 的[[PreferredCodecs]]的值，应用了以下过滤（或者如果[[PreferredCodecs]]为空则表示不设置）：</p> <p>如果方向是“sendrecv”，则排除 RTCRtpSender.getCapabilities（kind）.codecs 和 RTCRtpReceiver.getCapabilities（kind）.codecs 交集中未包含的任何编解码器。</p> <p>如果方向是“sendonly”，则排除 RTCRtpSender.getCapabilities（kind）.codecs 中未包含的任何编解码器。</p> <p>如果方向是“recvonly”，则排除 RTCRtpReceiver.getCapabilities（kind）.codecs 中未包含的任何编解码器。</p> <p>过滤绝不能改变编解码器首选项的顺序。</p> <p>让 offer 成为一个新创建的 RTCSessionDescriptionInit 字典，其类型成员初始化为字符串“offer”，其 sdp 成员初始化为 sdpString。</p> <p>将[[LastOffer]]内部值设置为 sdpString。</p> <p>用 Resolve 解决 p。</p> <p><code>createAnswer</code></p> <p>createAnswer 方法使用支持的会话配置生成[SDP] answer，该配置与远程配置中的参数兼容。与 createOffer 一样，返回的 SDP blob 包含附加到此 RTCPeerConnection 的本地 MediaStreamTracks 的描述，为此会话协商的编解码器/ RTP / RTCP 选项，以及 ICE 代理收集的任何候选项。可以提供选项参数以提供对生成的 answer 的附加控制。</p> <p>与 createOffer 一样，返回的描述应该反映系统的当前状态。会话描述必须仍然可以通过 setLocalDescription 保持可用，而不会导致错误，直到至少返回的 promise 的履行回调结束。</p> <p>作为 answer，生成的SDP将包含特定的编解码器/ RTP / RTCP 配置，该配置与相应的 offer 一起指定应如何建立媒体平面。 SDP 的生成必须遵循生成[JSEP]中描述的 answer 的适当过程。</p> <p>生成的 SDP 还将包含 ICE 代理的 usernameFragment，密码和 ICE 选项（在[ICE]，第14节中定义），还可以包含代理收集的任何本地候选。</p> <p>RTCPeerConnection 的配置中的证书值提供了应用程序为 RTCPeerConnection 配置的证书。这些证书以及任何默认证书用于生成一组证书指纹。这些证书指纹用于构建 SDP 和作为身份断言请求的输入。</p> <p>通过将类型设置为“pranswer”，可以将 answer 标记为临时，如[JSEP]（第4.1.8.1节）中所述。</p> <p>如果RTCPeerConnection配置为通过调用 setIdentityProvider 生成 Identity 断言，则会话描述应包含适当的断言。</p> <p>调用该方法时，用户代理必须执行以下步骤：</p> <p>让 connection 成为调用方法的 RTCPeerConnection 对象。</p> <p>如果connection的[[IsClosed]]值为 true，则返回使用新创建的 InvalidStateError 拒绝的 promise。</p> <p>如果使用身份提供程序配置连接，则在尚未开始的情况下开始身份声明请求过程。</p> <p>将以下步骤的结果返回到连接的操作队列：</p> <p>如果连接的信令状态既不是“have-remote-offer”也不是“have-local-pranswer”，则返回使用新创建的 InvalidStateError 拒绝的 promise。</p> <p>让 p 成为新的 Promise。</p> <p>同时，在给定 p 的情况下，开始创建 answer 的步骤。</p> <p>返回p。</p> <p>给出 p 创建 answer 的步骤如下：</p> <p>如果未使用一组证书构建连接，并且尚未生成一个证书，请等待生成。</p> <p>如果已配置提供者，则提供者是连接的当前配置身份提供者，否则为 null。</p> <p>如果 provider 为非 null，则等待身份断言请求过程完成。</p> <p>如果提供程序无法生成标识声明，请使用新创建的 NotReadableError 拒绝 p 并中止这些步骤。</p> <p>检查系统状态以确定生成 answer 所需的当前可用资源，如[JSEP]（第4.1.7节）中所述。</p> <p>如果此检查因任何原因失败，请使用新创建的 OperationError 拒绝 p 并中止这些步骤。</p> <p>在给定 p 的情况下，对运行最终步骤以创建 answer 的任务进行排队。</p> <p>给出承诺 p 创建 answer 的最后步骤如下：</p> <p>如果connection的[[IsClosed]] 值为 true，则中止这些步骤。</p> <p>如果以这样的方式修改连接，即需要对系统状态进行额外检查，或者如果其配置的 indentity 提供程序不再是提供者，那么并行开始步骤再次创建 answer，给定 p，并中止这些步骤。</p> <div class="language- extra-class"><pre><code>NOTE：如果在 RTCRtpTransceiver 的方向是“recvonly”时调用 createAnswer，则可能需要这样做，但在执行并行创建  answer 的步骤时，方向已更改为“sendrecv”，需要额外检查视频编码资源。

给定从先前检查获得的信息以及当前连接状态及其 RTCRtpTransceivers，以及来自提供者的身份断言（如果非空），生成 SDP answersdpString，如[JSEP]（第5.3节）中所述。 。

m =段的相关收发器的编解码器首选项被称为 RTCRtpTranceiver的[[PreferredCodecs]]的值，应用了以下过滤（或者如果[[PreferredCodecs]]为空则表示不设置）：
</code></pre></div><p>如果方向是“sendrecv”，则排除 RTCRtpSender.getCapabilities（kind）.codecs 和 RTCRtpReceiver.getCapabilities（kind）.codecs交集中未包含的任何编解码器。</p> <p>如果方向是“sendonly”，则排除 RTCRtpSender.getCapabilities（kind）.codecs 中未包含的任何编解码器。</p> <p>如果方向是“recvonly”，则排除 RTCRtpReceiver.getCapabilities（kind）.codecs 中未包含的任何编解码器。</p> <p>过滤绝不能改变编解码器首选项的顺序。</p> <p>让我们回答一个新创建的 RTCSessionDescriptionInit 字典，其类型成员初始化为字符串“answer”，其 sdp 成员初始化为 sdpString。</p> <p>将[[LastAnswer]]值设置为sdpString。</p> <p>Resolve p 并返回answer。</p> <p><code>setLocalDescription</code></p> <p>setLocalDescription 方法指示 RTCPeerConnection 将提供的 RTCSessionDescriptionInit 应用为本地描述。</p> <p>此 API 更改本地媒体状态。为了成功处理应用程序想要提供的从一种媒体格式更改为不同的不兼容格式的场景，RTCPeerConnection 必须能够同时支持使用当前和未决的本地描述（例如，支持两者中存在的编解码器）描述）直到收到最终 answer，此时 RTCPeerConnection 可以完全采用待处理的本地描述，或者如果远程端拒绝更改，则回滚到当前描述。</p> <p>如[JSEP]（第5.4节）中所述，从 createOffer 或 createAnswer 返回的 SDP 在传递给 setLocalDescription 之前不得更改。因此，当调用该方法时，用户代理必须运行以下步骤：</p> <p>让 description 成为 setLocalDescription 的第一个参数。</p> <p>如果 description.sdp 为空字符串且 description.type 为“answer” 或 “pranswer”，则将 description.sdp 设置为connection [[LastAnswer]]的值。</p> <p>如果 description.sdp 为空字符串且 description.type 为 “offer”，则将 description.sdp 设置为 connection [[LastOffer]]的值。</p> <p>返回设置描述所指示的 RTCSessionDescription 的结果。</p> <p>如[JSEP]（第5.9节）所述，调用此方法可能会触发 ICE 代理的 ICE 候选人收集过程。</p> <p><code>setRemoteDescription</code></p> <p>setRemoteDescription 方法指示 RTCPeerConnection 将提供的 RTCSessionDescriptionInit 应用为远程提供或 answer。此 API 更改本地媒体状态。</p> <p>调用该方法时，用户代理必须返回设置方法的第一个参数指示的 RTCSessionDescription 的结果。</p> <p>此外，处理远程描述以确定和验证对等体的身份。</p> <p>如果会话描述中存在 a = identity 属性，则浏览器验证标识声明。</p> <p>如果 peerIdentity 配置应用于 RTCPeerConnection，则会建立所提供值的目标对等体标识。或者，如果 RTCPeerConnection 先前已经验证了对等体的身份（即，解析了peerIdentity promise），那么这也建立了目标对等体身份。</p> <p>设置后，目标对等身份不能更改。</p> <p>如果设置了目标对等体标识，则必须在声明返回 setRemoteDescription 解析之前完成身份验证。如果身份验证失败，则会拒绝 setRemoteDescription 返回的承诺。</p> <p>如果没有目标对等体标识，则 setRemoteDescription 不会等待完成身份验证。</p> <p><code>addIceCandidate</code></p> <p>addIceCandidate 方法为 ICE 代理提供远程候选。当用候选成员的空字符串调用时，此方法还可用于指示远程候选者的结束。此方法使用的参数的唯一成员是 candidate，sdpMid，sdpMLineIndex 和 usernameFragment;其余的都被忽略了。调用该方法时，用户代理必须运行以下步骤：</p> <p>让候选人成为方法的参数。</p> <p>让 connection 成为调用方法的 RTCPeerConnection 对象。</p> <p>如果 candidate.candidate 不是空字符串且 candidate.sdpMid 和 candidate.sdpMLineIndex 都为 null，则返回使用新创建的 TypeError拒绝的 promise。</p> <p>将以下步骤的结果返回到连接的操作队列：</p> <p>如果 remoteDescription 为 null，则返回使用新创建的 InvalidStateError 拒绝的承诺。</p> <p>让p成为新的Promise。</p> <p>如果candidate.sdpMid不为null，请运行以下步骤：</p> <p>如果 candidate.sdpMid 不等于 remoteDescription 中任何媒体描述的中间部分，则使用新创建的 OperationError拒绝 p 并中止这些步骤。</p> <p>否则，如果candidate.sdpMLineIndex不为null，请运行以下步骤：</p> <p>如果 candidate.sdpMLineIndex 等于或大于 remoteDescription 中的媒体描述数，则使用新创建的 OperationError 拒绝 p 并中止这些步骤。</p> <p>如果 candidate.usernameFragment 既不是未定义也不是 null，并且不等于应用的远程描述的相应媒体描述中存在的任何用户名片段，则使用新创建的 OperationError 拒绝 p 并中止这些步骤。</p> <p>如果 candidate.usernameFragment 既不是未定义也不是 null，并且不等于应用的远程描述的相应媒体描述中存在的任何用户名片段，则使用新创建的 OperationError 拒绝p并中止这些步骤。</p> <p>同时，按照[JSEP]（第4.1.17节）中的描述添加 ICE 候选候选者。使用 candidate.usernameFragment 来标识 ICE 生成;如果 usernameFragment 为 null，则处理最近 ICE 生成的候选项。如果 candidate.candidate 是空字符串，则将候选处理作为对应的媒体描述和 ICE 候选生成的候选结束指示。如果 candidate.sdpMid 和 candidate.sdpMLineIndex 都为 null，则这适用于所有媒体描述。</p> <div class="language- extra-class"><pre><code>	zh:如果无法成功添加候选者，则用户代理必须对运行以下步骤的任务进行排队：
</code></pre></div><p>如果 connection的[[IsClosed]] 的值为true，则中止这些步骤。</p> <p>使用新创建的 OperationError 拒绝 p 并中止这些步骤。</p> <div class="language- extra-class"><pre><code>	zh:如果候选成功应用，则用户代理必须对运行以下步骤的任务进行排队：
</code></pre></div><p>如果 connection的[[IsClosed]] 的值为 true，则中止这些步骤。</p> <p>如果 connection.[[PendingRemoteDescription]] 不为 null，并且表示处理候选的 ICE 生成，则将候选添加到连接.[[PendingRemoteDescription]].sdp。</p> <p>如果 connection.[[CurrentRemoteDescription]]不为 null，并且表示处理候选的 ICE 生成，则将候选添加到connection.[[CurrentRemoteDescription]].sdp。</p> <p>Resolve p 并返回 undefined。</p> <p>返回p。</p> <p>NOTE:由于 WebIDL 处理，addIceCandidate（null） 被解释为具有默认字典的调用，在上述算法中，该字典指示所有媒体描述和 ICE 候选生成的候选结束。这是出于遗留原因的设计。</p> <p><code>getDefaultIceServers</code></p> <p>返回配置到浏览器中的 ICE 服务器列表。浏览器可能配置为使用本地或私有 STUN 或 TURN 服务器。此方法允许应用程序了解这些服务器并可选择使用它们。</p> <p>此列表可能是持久的，并且在起源之间是相同的。因此，它增加了浏览器的指纹表面。在隐私敏感的上下文中，浏览器可以考虑缓解，例如仅将此数据提供给白名单来源（或根本不提供）。</p> <p>NOTE:由于此信息的使用由应用程序开发人员自行决定，因此使用这些默认值配置用户代理本身并不会增加用户限制其 IP 地址暴露的能力。</p> <p><code>getConfiguration</code></p> <p>返回表示此 RTCPeerConnection 对象的当前配置的 RTCConfiguration 对象。</p> <p>调用此方法时，用户代理必须返回存储在[[Configuration]]内部值中的 RTCConfiguration 对象。</p> <p><code>setConfiguration</code></p> <p>setConfiguration 方法更新此 RTCPeerConnection 对象的配置。这包括更改 ICE 代理的配置。如[JSEP]（第3.5.1节）中所述，当 ICE 配置以需要新收集阶段的方式更改时，需要重新启动 ICE。</p> <p>调用 setConfiguration 方法时，用户代理必须运行以下步骤：</p> <p>让 connection 成为调用方法的 RTCPeerConnection。</p> <p>如果 connection的[[IsClosed]]的值为 true，则抛出 InvalidStateError。</p> <p>设置配置指定的配置。</p> <p><code>close</code></p> <p>当调用 close 方法时，用户代理必须运行以下步骤：</p> <p>让 connection 成为调用方法的 RTCPeerConnection 对象。</p> <p>如果 connection的[[IsClosed]]的值为 true，则中止这些步骤。</p> <p>将connection.[[IsClosed]]插槽设置为 true。</p> <p>将连接的信令状态设置为“closed”。</p> <p>让收发器成为执行 CollectTransceivers 算法的结果。对于收发器中的每个 RTCRtpTransceiver 收发器，请运行以下步骤：</p> <p>如果收发器的[[Stoped]]的值为真，则中止这些步骤。</p> <p>让发送者成为收发器的[[Sender]]。</p> <p>让接收器成为收发器的[[Receiver]]。</p> <p>停止向发件人发送媒体。</p> <p>按照[RFC3550]中的规定，为发送方发送的每个 RTP 流发送 RTCP BYE。</p> <p>停止使用接收器接收媒体。</p> <p>将接收者的[[ReceiverTrack]]的readyState设置为“ends”。</p> <p>将收发器的[[Stopped]]的值设置为 true。</p> <p>将每个连接的RTCDataChannels的[[ReadyState]]的值设置为“closed”。</p> <p>RTCDataChannels将突然关闭，并且不会调用关闭过程。</p> <p>如果connection.[[SctpTransport]] 不为 null，则通过发送 SCTP ABORT 块并将[[SctpTransportState]]设置为“closed”来拆除底层 SCTP 关联。</p> <p>将每个连接的 RTCDtlsTransports.[[DtlsTransportState]]的值设置为“closed”。</p> <p>销毁连接的 ICE 代理，突然结束任何活动的 ICE 处理并释放任何相关资源（例如 TURN 权限）。</p> <p>将每个连接的 RTCIceTransports 的[[IceTransportState]]插槽设置为“closed”。</p> <p>将连接的 ICE 连接状态设置为“closed”。</p> <p>将连接的连接状态设置为“closed”。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="../assets/js/app.cdf1d230.js" defer></script><script src="../assets/js/2.a9f4ac6f.js" defer></script><script src="../assets/js/44.f12c7850.js" defer></script>
  </body>
</html>
